Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT
    ELSE
    LBRACKET
    RBRACKET
    SQUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> INT MAIN LPAREN RPAREN bloco
Rule 2     sinal -> NOT PLUS
Rule 3     sinal -> NOT MINUS
Rule 4     sinal -> NOT
Rule 5     sinal -> PLUS
Rule 6     sinal -> MINUS
Rule 7     comando -> declaration
Rule 8     comando -> assignment SEMICOLON
Rule 9     comando -> if_statement
Rule 10    comando -> while_statement
Rule 11    comando -> for_statement
Rule 12    comando -> bloco
Rule 13    comando -> break_statement
Rule 14    comando -> continue_statement
Rule 15    comando -> return_statement
Rule 16    comando -> printf_statement
Rule 17    comando -> scanf_statement
Rule 18    comandos -> comando comandos
Rule 19    comandos -> comando
Rule 20    bloco -> LBRACE comandos RBRACE
Rule 21    bloco -> LBRACE RBRACE
Rule 22    parentheses -> LPAREN valor RPAREN
Rule 23    type -> INT
Rule 24    type -> FLOAT
Rule 25    type -> CHAR
Rule 26    type -> VOID
Rule 27    type -> BOOL
Rule 28    operador -> MULTIPLY
Rule 29    operador -> DIV
Rule 30    operador -> MOD
Rule 31    operador -> PLUS
Rule 32    operador -> MINUS
Rule 33    operador -> EQUAL
Rule 34    operador -> NEQUAL
Rule 35    operador -> GT
Rule 36    operador -> LT
Rule 37    operador -> GTE
Rule 38    operador -> LTE
Rule 39    operador -> AND
Rule 40    operador -> OR
Rule 41    boolean -> TRUE
Rule 42    boolean -> FALSE
Rule 43    valor -> NUMBER
Rule 44    valor -> NOME
Rule 45    valor -> CHARACTER
Rule 46    valor -> boolean
Rule 47    valor -> operation
Rule 48    valor -> parentheses
Rule 49    valor -> sinal valor
Rule 50    valores -> valor
Rule 51    valores -> valor COMMA valores
Rule 52    operation -> valor operador valor
Rule 53    assignment -> NOME ASSIGN valor
Rule 54    declaration_list -> NOME
Rule 55    declaration_list -> NOME declaration_list
Rule 56    declaration_list -> NOME ASSIGN valor
Rule 57    declaration_list -> NOME ASSIGN valor COMMA declaration_list
Rule 58    declaration -> type declaration_list SEMICOLON
Rule 59    if_statement -> IF LPAREN valor RPAREN bloco
Rule 60    while_statement -> WHILE LPAREN valor RPAREN bloco
Rule 61    for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
Rule 62    for_init -> assignment
Rule 63    for_init -> declaration
Rule 64    for_init -> valor
Rule 65    for_init -> empty
Rule 66    for_init -> assignment for_comma
Rule 67    for_init -> valor for_comma
Rule 68    for_init -> declaration for_comma
Rule 69    for_comma -> COMMA assignment
Rule 70    for_comma -> COMMA valor SEMICOLON
Rule 71    for_comma -> COMMA assignment for_comma
Rule 72    for_condition -> assignment
Rule 73    for_condition -> valor
Rule 74    for_condition -> valor for_comma
Rule 75    for_condition -> assignment for_comma
Rule 76    for_condition -> empty
Rule 77    for_update -> assignment
Rule 78    for_update -> valor
Rule 79    for_update -> valor for_comma
Rule 80    for_update -> assignment for_comma
Rule 81    for_update -> empty
Rule 82    scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON
Rule 83    printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON
Rule 84    printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON
Rule 85    break_statement -> BREAK SEMICOLON
Rule 86    continue_statement -> CONTINUE SEMICOLON
Rule 87    return_statement -> RETURN valor SEMICOLON
Rule 88    empty -> <empty>

Terminals, with rules where they appear

AND                  : 39
ASSIGN               : 53 56 57
BOOL                 : 27
BREAK                : 85
CHAR                 : 25
CHARACTER            : 45 82 83 84
COMMA                : 51 57 69 70 71 82 83
CONTINUE             : 86
DIV                  : 29
DOT                  : 
ELSE                 : 
EQUAL                : 33
FALSE                : 42
FLOAT                : 24
FOR                  : 61
GT                   : 35
GTE                  : 37
IF                   : 59
INT                  : 1 23
LBRACE               : 20 21
LBRACKET             : 
LPAREN               : 1 22 59 60 61 82 83 84
LT                   : 36
LTE                  : 38
MAIN                 : 1
MINUS                : 3 6 32
MOD                  : 30
MULTIPLY             : 28
NEQUAL               : 34
NOME                 : 44 53 54 55 56 57 82
NOT                  : 2 3 4
NUMBER               : 43
OR                   : 40
PLUS                 : 2 5 31
PRINTF               : 83 84
RBRACE               : 20 21
RBRACKET             : 
RETURN               : 87
RPAREN               : 1 22 59 60 61 82 83 84
SCANF                : 82
SEMICOLON            : 8 58 61 61 70 82 83 84 85 86 87
SQUOTE               : 
TRUE                 : 41
VOID                 : 26
WHILE                : 60
error                : 

Nonterminals, with rules where they appear

assignment           : 8 62 66 69 71 72 75 77 80
bloco                : 1 12 59 60
boolean              : 46
break_statement      : 13
comando              : 18 19 61
comandos             : 18 20
continue_statement   : 14
declaration          : 7 63 68
declaration_list     : 55 57 58
empty                : 65 76 81
for_comma            : 66 67 68 71 74 75 79 80
for_condition        : 61
for_init             : 61
for_statement        : 11
for_update           : 61
if_statement         : 9
operador             : 52
operation            : 47
parentheses          : 48
printf_statement     : 16
program              : 0
return_statement     : 15
scanf_statement      : 17
sinal                : 49
type                 : 58
valor                : 22 49 50 51 52 52 53 56 57 59 60 64 67 70 73 74 78 79 87
valores              : 51 83
while_statement      : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INT MAIN LPAREN RPAREN bloco

    INT             shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> INT . MAIN LPAREN RPAREN bloco

    MAIN            shift and go to state 3


state 3

    (1) program -> INT MAIN . LPAREN RPAREN bloco

    LPAREN          shift and go to state 4


state 4

    (1) program -> INT MAIN LPAREN . RPAREN bloco

    RPAREN          shift and go to state 5


state 5

    (1) program -> INT MAIN LPAREN RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 6

state 6

    (1) program -> INT MAIN LPAREN RPAREN bloco .

    $end            reduce using rule 1 (program -> INT MAIN LPAREN RPAREN bloco .)


state 7

    (20) bloco -> LBRACE . comandos RBRACE
    (21) bloco -> LBRACE . RBRACE
    (18) comandos -> . comando comandos
    (19) comandos -> . comando
    (7) comando -> . declaration
    (8) comando -> . assignment SEMICOLON
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (58) declaration -> . type declaration_list SEMICOLON
    (53) assignment -> . NOME ASSIGN valor
    (59) if_statement -> . IF LPAREN valor RPAREN bloco
    (60) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (61) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (85) break_statement -> . BREAK SEMICOLON
    (86) continue_statement -> . CONTINUE SEMICOLON
    (87) return_statement -> . RETURN valor SEMICOLON
    (83) printf_statement -> . PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> . PRINTF LPAREN CHARACTER RPAREN SEMICOLON
    (82) scanf_statement -> . SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    RBRACE          shift and go to state 9
    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comandos                       shift and go to state 8
    comando                        shift and go to state 10
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 8

    (20) bloco -> LBRACE comandos . RBRACE

    RBRACE          shift and go to state 37


state 9

    (21) bloco -> LBRACE RBRACE .

    $end            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    NOME            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    IF              reduce using rule 21 (bloco -> LBRACE RBRACE .)
    WHILE           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    FOR             reduce using rule 21 (bloco -> LBRACE RBRACE .)
    LBRACE          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    BREAK           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    CONTINUE        reduce using rule 21 (bloco -> LBRACE RBRACE .)
    RETURN          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    PRINTF          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    SCANF           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    INT             reduce using rule 21 (bloco -> LBRACE RBRACE .)
    FLOAT           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    CHAR            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    VOID            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    BOOL            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    RBRACE          reduce using rule 21 (bloco -> LBRACE RBRACE .)


state 10

    (18) comandos -> comando . comandos
    (19) comandos -> comando .
    (18) comandos -> . comando comandos
    (19) comandos -> . comando
    (7) comando -> . declaration
    (8) comando -> . assignment SEMICOLON
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (58) declaration -> . type declaration_list SEMICOLON
    (53) assignment -> . NOME ASSIGN valor
    (59) if_statement -> . IF LPAREN valor RPAREN bloco
    (60) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (61) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (85) break_statement -> . BREAK SEMICOLON
    (86) continue_statement -> . CONTINUE SEMICOLON
    (87) return_statement -> . RETURN valor SEMICOLON
    (83) printf_statement -> . PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> . PRINTF LPAREN CHARACTER RPAREN SEMICOLON
    (82) scanf_statement -> . SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    RBRACE          reduce using rule 19 (comandos -> comando .)
    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comando                        shift and go to state 10
    comandos                       shift and go to state 38
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 11

    (7) comando -> declaration .

    NOME            reduce using rule 7 (comando -> declaration .)
    IF              reduce using rule 7 (comando -> declaration .)
    WHILE           reduce using rule 7 (comando -> declaration .)
    FOR             reduce using rule 7 (comando -> declaration .)
    LBRACE          reduce using rule 7 (comando -> declaration .)
    BREAK           reduce using rule 7 (comando -> declaration .)
    CONTINUE        reduce using rule 7 (comando -> declaration .)
    RETURN          reduce using rule 7 (comando -> declaration .)
    PRINTF          reduce using rule 7 (comando -> declaration .)
    SCANF           reduce using rule 7 (comando -> declaration .)
    INT             reduce using rule 7 (comando -> declaration .)
    FLOAT           reduce using rule 7 (comando -> declaration .)
    CHAR            reduce using rule 7 (comando -> declaration .)
    VOID            reduce using rule 7 (comando -> declaration .)
    BOOL            reduce using rule 7 (comando -> declaration .)
    RBRACE          reduce using rule 7 (comando -> declaration .)


state 12

    (8) comando -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 39


state 13

    (9) comando -> if_statement .

    NOME            reduce using rule 9 (comando -> if_statement .)
    IF              reduce using rule 9 (comando -> if_statement .)
    WHILE           reduce using rule 9 (comando -> if_statement .)
    FOR             reduce using rule 9 (comando -> if_statement .)
    LBRACE          reduce using rule 9 (comando -> if_statement .)
    BREAK           reduce using rule 9 (comando -> if_statement .)
    CONTINUE        reduce using rule 9 (comando -> if_statement .)
    RETURN          reduce using rule 9 (comando -> if_statement .)
    PRINTF          reduce using rule 9 (comando -> if_statement .)
    SCANF           reduce using rule 9 (comando -> if_statement .)
    INT             reduce using rule 9 (comando -> if_statement .)
    FLOAT           reduce using rule 9 (comando -> if_statement .)
    CHAR            reduce using rule 9 (comando -> if_statement .)
    VOID            reduce using rule 9 (comando -> if_statement .)
    BOOL            reduce using rule 9 (comando -> if_statement .)
    RBRACE          reduce using rule 9 (comando -> if_statement .)


state 14

    (10) comando -> while_statement .

    NOME            reduce using rule 10 (comando -> while_statement .)
    IF              reduce using rule 10 (comando -> while_statement .)
    WHILE           reduce using rule 10 (comando -> while_statement .)
    FOR             reduce using rule 10 (comando -> while_statement .)
    LBRACE          reduce using rule 10 (comando -> while_statement .)
    BREAK           reduce using rule 10 (comando -> while_statement .)
    CONTINUE        reduce using rule 10 (comando -> while_statement .)
    RETURN          reduce using rule 10 (comando -> while_statement .)
    PRINTF          reduce using rule 10 (comando -> while_statement .)
    SCANF           reduce using rule 10 (comando -> while_statement .)
    INT             reduce using rule 10 (comando -> while_statement .)
    FLOAT           reduce using rule 10 (comando -> while_statement .)
    CHAR            reduce using rule 10 (comando -> while_statement .)
    VOID            reduce using rule 10 (comando -> while_statement .)
    BOOL            reduce using rule 10 (comando -> while_statement .)
    RBRACE          reduce using rule 10 (comando -> while_statement .)


state 15

    (11) comando -> for_statement .

    NOME            reduce using rule 11 (comando -> for_statement .)
    IF              reduce using rule 11 (comando -> for_statement .)
    WHILE           reduce using rule 11 (comando -> for_statement .)
    FOR             reduce using rule 11 (comando -> for_statement .)
    LBRACE          reduce using rule 11 (comando -> for_statement .)
    BREAK           reduce using rule 11 (comando -> for_statement .)
    CONTINUE        reduce using rule 11 (comando -> for_statement .)
    RETURN          reduce using rule 11 (comando -> for_statement .)
    PRINTF          reduce using rule 11 (comando -> for_statement .)
    SCANF           reduce using rule 11 (comando -> for_statement .)
    INT             reduce using rule 11 (comando -> for_statement .)
    FLOAT           reduce using rule 11 (comando -> for_statement .)
    CHAR            reduce using rule 11 (comando -> for_statement .)
    VOID            reduce using rule 11 (comando -> for_statement .)
    BOOL            reduce using rule 11 (comando -> for_statement .)
    RBRACE          reduce using rule 11 (comando -> for_statement .)


state 16

    (12) comando -> bloco .

    NOME            reduce using rule 12 (comando -> bloco .)
    IF              reduce using rule 12 (comando -> bloco .)
    WHILE           reduce using rule 12 (comando -> bloco .)
    FOR             reduce using rule 12 (comando -> bloco .)
    LBRACE          reduce using rule 12 (comando -> bloco .)
    BREAK           reduce using rule 12 (comando -> bloco .)
    CONTINUE        reduce using rule 12 (comando -> bloco .)
    RETURN          reduce using rule 12 (comando -> bloco .)
    PRINTF          reduce using rule 12 (comando -> bloco .)
    SCANF           reduce using rule 12 (comando -> bloco .)
    INT             reduce using rule 12 (comando -> bloco .)
    FLOAT           reduce using rule 12 (comando -> bloco .)
    CHAR            reduce using rule 12 (comando -> bloco .)
    VOID            reduce using rule 12 (comando -> bloco .)
    BOOL            reduce using rule 12 (comando -> bloco .)
    RBRACE          reduce using rule 12 (comando -> bloco .)


state 17

    (13) comando -> break_statement .

    NOME            reduce using rule 13 (comando -> break_statement .)
    IF              reduce using rule 13 (comando -> break_statement .)
    WHILE           reduce using rule 13 (comando -> break_statement .)
    FOR             reduce using rule 13 (comando -> break_statement .)
    LBRACE          reduce using rule 13 (comando -> break_statement .)
    BREAK           reduce using rule 13 (comando -> break_statement .)
    CONTINUE        reduce using rule 13 (comando -> break_statement .)
    RETURN          reduce using rule 13 (comando -> break_statement .)
    PRINTF          reduce using rule 13 (comando -> break_statement .)
    SCANF           reduce using rule 13 (comando -> break_statement .)
    INT             reduce using rule 13 (comando -> break_statement .)
    FLOAT           reduce using rule 13 (comando -> break_statement .)
    CHAR            reduce using rule 13 (comando -> break_statement .)
    VOID            reduce using rule 13 (comando -> break_statement .)
    BOOL            reduce using rule 13 (comando -> break_statement .)
    RBRACE          reduce using rule 13 (comando -> break_statement .)


state 18

    (14) comando -> continue_statement .

    NOME            reduce using rule 14 (comando -> continue_statement .)
    IF              reduce using rule 14 (comando -> continue_statement .)
    WHILE           reduce using rule 14 (comando -> continue_statement .)
    FOR             reduce using rule 14 (comando -> continue_statement .)
    LBRACE          reduce using rule 14 (comando -> continue_statement .)
    BREAK           reduce using rule 14 (comando -> continue_statement .)
    CONTINUE        reduce using rule 14 (comando -> continue_statement .)
    RETURN          reduce using rule 14 (comando -> continue_statement .)
    PRINTF          reduce using rule 14 (comando -> continue_statement .)
    SCANF           reduce using rule 14 (comando -> continue_statement .)
    INT             reduce using rule 14 (comando -> continue_statement .)
    FLOAT           reduce using rule 14 (comando -> continue_statement .)
    CHAR            reduce using rule 14 (comando -> continue_statement .)
    VOID            reduce using rule 14 (comando -> continue_statement .)
    BOOL            reduce using rule 14 (comando -> continue_statement .)
    RBRACE          reduce using rule 14 (comando -> continue_statement .)


state 19

    (15) comando -> return_statement .

    NOME            reduce using rule 15 (comando -> return_statement .)
    IF              reduce using rule 15 (comando -> return_statement .)
    WHILE           reduce using rule 15 (comando -> return_statement .)
    FOR             reduce using rule 15 (comando -> return_statement .)
    LBRACE          reduce using rule 15 (comando -> return_statement .)
    BREAK           reduce using rule 15 (comando -> return_statement .)
    CONTINUE        reduce using rule 15 (comando -> return_statement .)
    RETURN          reduce using rule 15 (comando -> return_statement .)
    PRINTF          reduce using rule 15 (comando -> return_statement .)
    SCANF           reduce using rule 15 (comando -> return_statement .)
    INT             reduce using rule 15 (comando -> return_statement .)
    FLOAT           reduce using rule 15 (comando -> return_statement .)
    CHAR            reduce using rule 15 (comando -> return_statement .)
    VOID            reduce using rule 15 (comando -> return_statement .)
    BOOL            reduce using rule 15 (comando -> return_statement .)
    RBRACE          reduce using rule 15 (comando -> return_statement .)


state 20

    (16) comando -> printf_statement .

    NOME            reduce using rule 16 (comando -> printf_statement .)
    IF              reduce using rule 16 (comando -> printf_statement .)
    WHILE           reduce using rule 16 (comando -> printf_statement .)
    FOR             reduce using rule 16 (comando -> printf_statement .)
    LBRACE          reduce using rule 16 (comando -> printf_statement .)
    BREAK           reduce using rule 16 (comando -> printf_statement .)
    CONTINUE        reduce using rule 16 (comando -> printf_statement .)
    RETURN          reduce using rule 16 (comando -> printf_statement .)
    PRINTF          reduce using rule 16 (comando -> printf_statement .)
    SCANF           reduce using rule 16 (comando -> printf_statement .)
    INT             reduce using rule 16 (comando -> printf_statement .)
    FLOAT           reduce using rule 16 (comando -> printf_statement .)
    CHAR            reduce using rule 16 (comando -> printf_statement .)
    VOID            reduce using rule 16 (comando -> printf_statement .)
    BOOL            reduce using rule 16 (comando -> printf_statement .)
    RBRACE          reduce using rule 16 (comando -> printf_statement .)


state 21

    (17) comando -> scanf_statement .

    NOME            reduce using rule 17 (comando -> scanf_statement .)
    IF              reduce using rule 17 (comando -> scanf_statement .)
    WHILE           reduce using rule 17 (comando -> scanf_statement .)
    FOR             reduce using rule 17 (comando -> scanf_statement .)
    LBRACE          reduce using rule 17 (comando -> scanf_statement .)
    BREAK           reduce using rule 17 (comando -> scanf_statement .)
    CONTINUE        reduce using rule 17 (comando -> scanf_statement .)
    RETURN          reduce using rule 17 (comando -> scanf_statement .)
    PRINTF          reduce using rule 17 (comando -> scanf_statement .)
    SCANF           reduce using rule 17 (comando -> scanf_statement .)
    INT             reduce using rule 17 (comando -> scanf_statement .)
    FLOAT           reduce using rule 17 (comando -> scanf_statement .)
    CHAR            reduce using rule 17 (comando -> scanf_statement .)
    VOID            reduce using rule 17 (comando -> scanf_statement .)
    BOOL            reduce using rule 17 (comando -> scanf_statement .)
    RBRACE          reduce using rule 17 (comando -> scanf_statement .)


state 22

    (58) declaration -> type . declaration_list SEMICOLON
    (54) declaration_list -> . NOME
    (55) declaration_list -> . NOME declaration_list
    (56) declaration_list -> . NOME ASSIGN valor
    (57) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    NOME            shift and go to state 41

    declaration_list               shift and go to state 40

state 23

    (53) assignment -> NOME . ASSIGN valor

    ASSIGN          shift and go to state 42


state 24

    (59) if_statement -> IF . LPAREN valor RPAREN bloco

    LPAREN          shift and go to state 43


state 25

    (60) while_statement -> WHILE . LPAREN valor RPAREN bloco

    LPAREN          shift and go to state 44


state 26

    (61) for_statement -> FOR . LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    LPAREN          shift and go to state 45


state 27

    (85) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 46


state 28

    (86) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 47


state 29

    (87) return_statement -> RETURN . valor SEMICOLON
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 48
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 30

    (83) printf_statement -> PRINTF . LPAREN CHARACTER COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> PRINTF . LPAREN CHARACTER RPAREN SEMICOLON

    LPAREN          shift and go to state 62


state 31

    (82) scanf_statement -> SCANF . LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON

    LPAREN          shift and go to state 63


state 32

    (23) type -> INT .

    NOME            reduce using rule 23 (type -> INT .)


state 33

    (24) type -> FLOAT .

    NOME            reduce using rule 24 (type -> FLOAT .)


state 34

    (25) type -> CHAR .

    NOME            reduce using rule 25 (type -> CHAR .)


state 35

    (26) type -> VOID .

    NOME            reduce using rule 26 (type -> VOID .)


state 36

    (27) type -> BOOL .

    NOME            reduce using rule 27 (type -> BOOL .)


state 37

    (20) bloco -> LBRACE comandos RBRACE .

    $end            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    NOME            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    IF              reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    WHILE           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    FOR             reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    LBRACE          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    BREAK           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    CONTINUE        reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    RETURN          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    PRINTF          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    SCANF           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    INT             reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    FLOAT           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    CHAR            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    VOID            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    BOOL            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    RBRACE          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)


state 38

    (18) comandos -> comando comandos .

    RBRACE          reduce using rule 18 (comandos -> comando comandos .)


state 39

    (8) comando -> assignment SEMICOLON .

    NOME            reduce using rule 8 (comando -> assignment SEMICOLON .)
    IF              reduce using rule 8 (comando -> assignment SEMICOLON .)
    WHILE           reduce using rule 8 (comando -> assignment SEMICOLON .)
    FOR             reduce using rule 8 (comando -> assignment SEMICOLON .)
    LBRACE          reduce using rule 8 (comando -> assignment SEMICOLON .)
    BREAK           reduce using rule 8 (comando -> assignment SEMICOLON .)
    CONTINUE        reduce using rule 8 (comando -> assignment SEMICOLON .)
    RETURN          reduce using rule 8 (comando -> assignment SEMICOLON .)
    PRINTF          reduce using rule 8 (comando -> assignment SEMICOLON .)
    SCANF           reduce using rule 8 (comando -> assignment SEMICOLON .)
    INT             reduce using rule 8 (comando -> assignment SEMICOLON .)
    FLOAT           reduce using rule 8 (comando -> assignment SEMICOLON .)
    CHAR            reduce using rule 8 (comando -> assignment SEMICOLON .)
    VOID            reduce using rule 8 (comando -> assignment SEMICOLON .)
    BOOL            reduce using rule 8 (comando -> assignment SEMICOLON .)
    RBRACE          reduce using rule 8 (comando -> assignment SEMICOLON .)


state 40

    (58) declaration -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 64


state 41

    (54) declaration_list -> NOME .
    (55) declaration_list -> NOME . declaration_list
    (56) declaration_list -> NOME . ASSIGN valor
    (57) declaration_list -> NOME . ASSIGN valor COMMA declaration_list
    (54) declaration_list -> . NOME
    (55) declaration_list -> . NOME declaration_list
    (56) declaration_list -> . NOME ASSIGN valor
    (57) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    SEMICOLON       reduce using rule 54 (declaration_list -> NOME .)
    ASSIGN          shift and go to state 66
    NOME            shift and go to state 41

    declaration_list               shift and go to state 65

state 42

    (53) assignment -> NOME ASSIGN . valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 67
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 43

    (59) if_statement -> IF LPAREN . valor RPAREN bloco
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 68
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 44

    (60) while_statement -> WHILE LPAREN . valor RPAREN bloco
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 69
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 45

    (61) for_statement -> FOR LPAREN . for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (62) for_init -> . assignment
    (63) for_init -> . declaration
    (64) for_init -> . valor
    (65) for_init -> . empty
    (66) for_init -> . assignment for_comma
    (67) for_init -> . valor for_comma
    (68) for_init -> . declaration for_comma
    (53) assignment -> . NOME ASSIGN valor
    (58) declaration -> . type declaration_list SEMICOLON
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (88) empty -> .
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NOME            shift and go to state 75
    NUMBER          shift and go to state 49
    CHARACTER       shift and go to state 51
    SEMICOLON       reduce using rule 88 (empty -> .)
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    for_init                       shift and go to state 70
    assignment                     shift and go to state 71
    declaration                    shift and go to state 72
    valor                          shift and go to state 73
    empty                          shift and go to state 74
    type                           shift and go to state 22
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 46

    (85) break_statement -> BREAK SEMICOLON .

    NOME            reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    SCANF           reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 85 (break_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 85 (break_statement -> BREAK SEMICOLON .)


state 47

    (86) continue_statement -> CONTINUE SEMICOLON .

    NOME            reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    PRINTF          reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    SCANF           reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 86 (continue_statement -> CONTINUE SEMICOLON .)


state 48

    (87) return_statement -> RETURN valor . SEMICOLON
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       shift and go to state 76
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 49

    (43) valor -> NUMBER .

    SEMICOLON       reduce using rule 43 (valor -> NUMBER .)
    MULTIPLY        reduce using rule 43 (valor -> NUMBER .)
    DIV             reduce using rule 43 (valor -> NUMBER .)
    MOD             reduce using rule 43 (valor -> NUMBER .)
    PLUS            reduce using rule 43 (valor -> NUMBER .)
    MINUS           reduce using rule 43 (valor -> NUMBER .)
    EQUAL           reduce using rule 43 (valor -> NUMBER .)
    NEQUAL          reduce using rule 43 (valor -> NUMBER .)
    GT              reduce using rule 43 (valor -> NUMBER .)
    LT              reduce using rule 43 (valor -> NUMBER .)
    GTE             reduce using rule 43 (valor -> NUMBER .)
    LTE             reduce using rule 43 (valor -> NUMBER .)
    AND             reduce using rule 43 (valor -> NUMBER .)
    OR              reduce using rule 43 (valor -> NUMBER .)
    COMMA           reduce using rule 43 (valor -> NUMBER .)
    RPAREN          reduce using rule 43 (valor -> NUMBER .)


state 50

    (44) valor -> NOME .

    SEMICOLON       reduce using rule 44 (valor -> NOME .)
    MULTIPLY        reduce using rule 44 (valor -> NOME .)
    DIV             reduce using rule 44 (valor -> NOME .)
    MOD             reduce using rule 44 (valor -> NOME .)
    PLUS            reduce using rule 44 (valor -> NOME .)
    MINUS           reduce using rule 44 (valor -> NOME .)
    EQUAL           reduce using rule 44 (valor -> NOME .)
    NEQUAL          reduce using rule 44 (valor -> NOME .)
    GT              reduce using rule 44 (valor -> NOME .)
    LT              reduce using rule 44 (valor -> NOME .)
    GTE             reduce using rule 44 (valor -> NOME .)
    LTE             reduce using rule 44 (valor -> NOME .)
    AND             reduce using rule 44 (valor -> NOME .)
    OR              reduce using rule 44 (valor -> NOME .)
    COMMA           reduce using rule 44 (valor -> NOME .)
    RPAREN          reduce using rule 44 (valor -> NOME .)


state 51

    (45) valor -> CHARACTER .

    SEMICOLON       reduce using rule 45 (valor -> CHARACTER .)
    MULTIPLY        reduce using rule 45 (valor -> CHARACTER .)
    DIV             reduce using rule 45 (valor -> CHARACTER .)
    MOD             reduce using rule 45 (valor -> CHARACTER .)
    PLUS            reduce using rule 45 (valor -> CHARACTER .)
    MINUS           reduce using rule 45 (valor -> CHARACTER .)
    EQUAL           reduce using rule 45 (valor -> CHARACTER .)
    NEQUAL          reduce using rule 45 (valor -> CHARACTER .)
    GT              reduce using rule 45 (valor -> CHARACTER .)
    LT              reduce using rule 45 (valor -> CHARACTER .)
    GTE             reduce using rule 45 (valor -> CHARACTER .)
    LTE             reduce using rule 45 (valor -> CHARACTER .)
    AND             reduce using rule 45 (valor -> CHARACTER .)
    OR              reduce using rule 45 (valor -> CHARACTER .)
    COMMA           reduce using rule 45 (valor -> CHARACTER .)
    RPAREN          reduce using rule 45 (valor -> CHARACTER .)


state 52

    (46) valor -> boolean .

    SEMICOLON       reduce using rule 46 (valor -> boolean .)
    MULTIPLY        reduce using rule 46 (valor -> boolean .)
    DIV             reduce using rule 46 (valor -> boolean .)
    MOD             reduce using rule 46 (valor -> boolean .)
    PLUS            reduce using rule 46 (valor -> boolean .)
    MINUS           reduce using rule 46 (valor -> boolean .)
    EQUAL           reduce using rule 46 (valor -> boolean .)
    NEQUAL          reduce using rule 46 (valor -> boolean .)
    GT              reduce using rule 46 (valor -> boolean .)
    LT              reduce using rule 46 (valor -> boolean .)
    GTE             reduce using rule 46 (valor -> boolean .)
    LTE             reduce using rule 46 (valor -> boolean .)
    AND             reduce using rule 46 (valor -> boolean .)
    OR              reduce using rule 46 (valor -> boolean .)
    COMMA           reduce using rule 46 (valor -> boolean .)
    RPAREN          reduce using rule 46 (valor -> boolean .)


state 53

    (47) valor -> operation .

    SEMICOLON       reduce using rule 47 (valor -> operation .)
    MULTIPLY        reduce using rule 47 (valor -> operation .)
    DIV             reduce using rule 47 (valor -> operation .)
    MOD             reduce using rule 47 (valor -> operation .)
    PLUS            reduce using rule 47 (valor -> operation .)
    MINUS           reduce using rule 47 (valor -> operation .)
    EQUAL           reduce using rule 47 (valor -> operation .)
    NEQUAL          reduce using rule 47 (valor -> operation .)
    GT              reduce using rule 47 (valor -> operation .)
    LT              reduce using rule 47 (valor -> operation .)
    GTE             reduce using rule 47 (valor -> operation .)
    LTE             reduce using rule 47 (valor -> operation .)
    AND             reduce using rule 47 (valor -> operation .)
    OR              reduce using rule 47 (valor -> operation .)
    COMMA           reduce using rule 47 (valor -> operation .)
    RPAREN          reduce using rule 47 (valor -> operation .)


state 54

    (48) valor -> parentheses .

    SEMICOLON       reduce using rule 48 (valor -> parentheses .)
    MULTIPLY        reduce using rule 48 (valor -> parentheses .)
    DIV             reduce using rule 48 (valor -> parentheses .)
    MOD             reduce using rule 48 (valor -> parentheses .)
    PLUS            reduce using rule 48 (valor -> parentheses .)
    MINUS           reduce using rule 48 (valor -> parentheses .)
    EQUAL           reduce using rule 48 (valor -> parentheses .)
    NEQUAL          reduce using rule 48 (valor -> parentheses .)
    GT              reduce using rule 48 (valor -> parentheses .)
    LT              reduce using rule 48 (valor -> parentheses .)
    GTE             reduce using rule 48 (valor -> parentheses .)
    LTE             reduce using rule 48 (valor -> parentheses .)
    AND             reduce using rule 48 (valor -> parentheses .)
    OR              reduce using rule 48 (valor -> parentheses .)
    COMMA           reduce using rule 48 (valor -> parentheses .)
    RPAREN          reduce using rule 48 (valor -> parentheses .)


state 55

    (49) valor -> sinal . valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    sinal                          shift and go to state 55
    valor                          shift and go to state 91
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54

state 56

    (41) boolean -> TRUE .

    SEMICOLON       reduce using rule 41 (boolean -> TRUE .)
    MULTIPLY        reduce using rule 41 (boolean -> TRUE .)
    DIV             reduce using rule 41 (boolean -> TRUE .)
    MOD             reduce using rule 41 (boolean -> TRUE .)
    PLUS            reduce using rule 41 (boolean -> TRUE .)
    MINUS           reduce using rule 41 (boolean -> TRUE .)
    EQUAL           reduce using rule 41 (boolean -> TRUE .)
    NEQUAL          reduce using rule 41 (boolean -> TRUE .)
    GT              reduce using rule 41 (boolean -> TRUE .)
    LT              reduce using rule 41 (boolean -> TRUE .)
    GTE             reduce using rule 41 (boolean -> TRUE .)
    LTE             reduce using rule 41 (boolean -> TRUE .)
    AND             reduce using rule 41 (boolean -> TRUE .)
    OR              reduce using rule 41 (boolean -> TRUE .)
    COMMA           reduce using rule 41 (boolean -> TRUE .)
    RPAREN          reduce using rule 41 (boolean -> TRUE .)


state 57

    (42) boolean -> FALSE .

    SEMICOLON       reduce using rule 42 (boolean -> FALSE .)
    MULTIPLY        reduce using rule 42 (boolean -> FALSE .)
    DIV             reduce using rule 42 (boolean -> FALSE .)
    MOD             reduce using rule 42 (boolean -> FALSE .)
    PLUS            reduce using rule 42 (boolean -> FALSE .)
    MINUS           reduce using rule 42 (boolean -> FALSE .)
    EQUAL           reduce using rule 42 (boolean -> FALSE .)
    NEQUAL          reduce using rule 42 (boolean -> FALSE .)
    GT              reduce using rule 42 (boolean -> FALSE .)
    LT              reduce using rule 42 (boolean -> FALSE .)
    GTE             reduce using rule 42 (boolean -> FALSE .)
    LTE             reduce using rule 42 (boolean -> FALSE .)
    AND             reduce using rule 42 (boolean -> FALSE .)
    OR              reduce using rule 42 (boolean -> FALSE .)
    COMMA           reduce using rule 42 (boolean -> FALSE .)
    RPAREN          reduce using rule 42 (boolean -> FALSE .)


state 58

    (22) parentheses -> LPAREN . valor RPAREN
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 92
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 59

    (2) sinal -> NOT . PLUS
    (3) sinal -> NOT . MINUS
    (4) sinal -> NOT .

    NUMBER          reduce using rule 4 (sinal -> NOT .)
    NOME            reduce using rule 4 (sinal -> NOT .)
    CHARACTER       reduce using rule 4 (sinal -> NOT .)
    TRUE            reduce using rule 4 (sinal -> NOT .)
    FALSE           reduce using rule 4 (sinal -> NOT .)
    LPAREN          reduce using rule 4 (sinal -> NOT .)
    NOT             reduce using rule 4 (sinal -> NOT .)
    PLUS            reduce using rule 4 (sinal -> NOT .)
    MINUS           reduce using rule 4 (sinal -> NOT .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]


state 60

    (5) sinal -> PLUS .

    NUMBER          reduce using rule 5 (sinal -> PLUS .)
    NOME            reduce using rule 5 (sinal -> PLUS .)
    CHARACTER       reduce using rule 5 (sinal -> PLUS .)
    TRUE            reduce using rule 5 (sinal -> PLUS .)
    FALSE           reduce using rule 5 (sinal -> PLUS .)
    LPAREN          reduce using rule 5 (sinal -> PLUS .)
    NOT             reduce using rule 5 (sinal -> PLUS .)
    PLUS            reduce using rule 5 (sinal -> PLUS .)
    MINUS           reduce using rule 5 (sinal -> PLUS .)


state 61

    (6) sinal -> MINUS .

    NUMBER          reduce using rule 6 (sinal -> MINUS .)
    NOME            reduce using rule 6 (sinal -> MINUS .)
    CHARACTER       reduce using rule 6 (sinal -> MINUS .)
    TRUE            reduce using rule 6 (sinal -> MINUS .)
    FALSE           reduce using rule 6 (sinal -> MINUS .)
    LPAREN          reduce using rule 6 (sinal -> MINUS .)
    NOT             reduce using rule 6 (sinal -> MINUS .)
    PLUS            reduce using rule 6 (sinal -> MINUS .)
    MINUS           reduce using rule 6 (sinal -> MINUS .)


state 62

    (83) printf_statement -> PRINTF LPAREN . CHARACTER COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> PRINTF LPAREN . CHARACTER RPAREN SEMICOLON

    CHARACTER       shift and go to state 95


state 63

    (82) scanf_statement -> SCANF LPAREN . CHARACTER COMMA NOME RPAREN SEMICOLON

    CHARACTER       shift and go to state 96


state 64

    (58) declaration -> type declaration_list SEMICOLON .

    NOME            reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    IF              reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    WHILE           reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    FOR             reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    LBRACE          reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    BREAK           reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    CONTINUE        reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    RETURN          reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    PRINTF          reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    SCANF           reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    INT             reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    FLOAT           reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    CHAR            reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    VOID            reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    BOOL            reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    COMMA           reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)
    SEMICOLON       reduce using rule 58 (declaration -> type declaration_list SEMICOLON .)


state 65

    (55) declaration_list -> NOME declaration_list .

    SEMICOLON       reduce using rule 55 (declaration_list -> NOME declaration_list .)


state 66

    (56) declaration_list -> NOME ASSIGN . valor
    (57) declaration_list -> NOME ASSIGN . valor COMMA declaration_list
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 97
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 67

    (53) assignment -> NOME ASSIGN valor .
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 53 (assignment -> NOME ASSIGN valor .)
    COMMA           reduce using rule 53 (assignment -> NOME ASSIGN valor .)
    RPAREN          reduce using rule 53 (assignment -> NOME ASSIGN valor .)
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 68

    (59) if_statement -> IF LPAREN valor . RPAREN bloco
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 98
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 69

    (60) while_statement -> WHILE LPAREN valor . RPAREN bloco
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 99
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 70

    (61) for_statement -> FOR LPAREN for_init . SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 100


state 71

    (62) for_init -> assignment .
    (66) for_init -> assignment . for_comma
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 62 (for_init -> assignment .)
    COMMA           shift and go to state 102

    for_comma                      shift and go to state 101

state 72

    (63) for_init -> declaration .
    (68) for_init -> declaration . for_comma
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 63 (for_init -> declaration .)
    COMMA           shift and go to state 102

    for_comma                      shift and go to state 103

state 73

    (64) for_init -> valor .
    (67) for_init -> valor . for_comma
    (52) operation -> valor . operador valor
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 64 (for_init -> valor .)
    COMMA           shift and go to state 102
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    for_comma                      shift and go to state 104
    operador                       shift and go to state 77

state 74

    (65) for_init -> empty .

    SEMICOLON       reduce using rule 65 (for_init -> empty .)


state 75

    (53) assignment -> NOME . ASSIGN valor
    (44) valor -> NOME .

    ASSIGN          shift and go to state 42
    COMMA           reduce using rule 44 (valor -> NOME .)
    MULTIPLY        reduce using rule 44 (valor -> NOME .)
    DIV             reduce using rule 44 (valor -> NOME .)
    MOD             reduce using rule 44 (valor -> NOME .)
    PLUS            reduce using rule 44 (valor -> NOME .)
    MINUS           reduce using rule 44 (valor -> NOME .)
    EQUAL           reduce using rule 44 (valor -> NOME .)
    NEQUAL          reduce using rule 44 (valor -> NOME .)
    GT              reduce using rule 44 (valor -> NOME .)
    LT              reduce using rule 44 (valor -> NOME .)
    GTE             reduce using rule 44 (valor -> NOME .)
    LTE             reduce using rule 44 (valor -> NOME .)
    AND             reduce using rule 44 (valor -> NOME .)
    OR              reduce using rule 44 (valor -> NOME .)
    SEMICOLON       reduce using rule 44 (valor -> NOME .)
    RPAREN          reduce using rule 44 (valor -> NOME .)


state 76

    (87) return_statement -> RETURN valor SEMICOLON .

    NOME            reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    IF              reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    WHILE           reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    FOR             reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    LBRACE          reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    BREAK           reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    CONTINUE        reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    RETURN          reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    PRINTF          reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    SCANF           reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    INT             reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    FLOAT           reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    CHAR            reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    VOID            reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    BOOL            reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)
    RBRACE          reduce using rule 87 (return_statement -> RETURN valor SEMICOLON .)


state 77

    (52) operation -> valor operador . valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 105
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 78

    (28) operador -> MULTIPLY .

    NUMBER          reduce using rule 28 (operador -> MULTIPLY .)
    NOME            reduce using rule 28 (operador -> MULTIPLY .)
    CHARACTER       reduce using rule 28 (operador -> MULTIPLY .)
    TRUE            reduce using rule 28 (operador -> MULTIPLY .)
    FALSE           reduce using rule 28 (operador -> MULTIPLY .)
    LPAREN          reduce using rule 28 (operador -> MULTIPLY .)
    NOT             reduce using rule 28 (operador -> MULTIPLY .)
    PLUS            reduce using rule 28 (operador -> MULTIPLY .)
    MINUS           reduce using rule 28 (operador -> MULTIPLY .)


state 79

    (29) operador -> DIV .

    NUMBER          reduce using rule 29 (operador -> DIV .)
    NOME            reduce using rule 29 (operador -> DIV .)
    CHARACTER       reduce using rule 29 (operador -> DIV .)
    TRUE            reduce using rule 29 (operador -> DIV .)
    FALSE           reduce using rule 29 (operador -> DIV .)
    LPAREN          reduce using rule 29 (operador -> DIV .)
    NOT             reduce using rule 29 (operador -> DIV .)
    PLUS            reduce using rule 29 (operador -> DIV .)
    MINUS           reduce using rule 29 (operador -> DIV .)


state 80

    (30) operador -> MOD .

    NUMBER          reduce using rule 30 (operador -> MOD .)
    NOME            reduce using rule 30 (operador -> MOD .)
    CHARACTER       reduce using rule 30 (operador -> MOD .)
    TRUE            reduce using rule 30 (operador -> MOD .)
    FALSE           reduce using rule 30 (operador -> MOD .)
    LPAREN          reduce using rule 30 (operador -> MOD .)
    NOT             reduce using rule 30 (operador -> MOD .)
    PLUS            reduce using rule 30 (operador -> MOD .)
    MINUS           reduce using rule 30 (operador -> MOD .)


state 81

    (31) operador -> PLUS .

    NUMBER          reduce using rule 31 (operador -> PLUS .)
    NOME            reduce using rule 31 (operador -> PLUS .)
    CHARACTER       reduce using rule 31 (operador -> PLUS .)
    TRUE            reduce using rule 31 (operador -> PLUS .)
    FALSE           reduce using rule 31 (operador -> PLUS .)
    LPAREN          reduce using rule 31 (operador -> PLUS .)
    NOT             reduce using rule 31 (operador -> PLUS .)
    PLUS            reduce using rule 31 (operador -> PLUS .)
    MINUS           reduce using rule 31 (operador -> PLUS .)


state 82

    (32) operador -> MINUS .

    NUMBER          reduce using rule 32 (operador -> MINUS .)
    NOME            reduce using rule 32 (operador -> MINUS .)
    CHARACTER       reduce using rule 32 (operador -> MINUS .)
    TRUE            reduce using rule 32 (operador -> MINUS .)
    FALSE           reduce using rule 32 (operador -> MINUS .)
    LPAREN          reduce using rule 32 (operador -> MINUS .)
    NOT             reduce using rule 32 (operador -> MINUS .)
    PLUS            reduce using rule 32 (operador -> MINUS .)
    MINUS           reduce using rule 32 (operador -> MINUS .)


state 83

    (33) operador -> EQUAL .

    NUMBER          reduce using rule 33 (operador -> EQUAL .)
    NOME            reduce using rule 33 (operador -> EQUAL .)
    CHARACTER       reduce using rule 33 (operador -> EQUAL .)
    TRUE            reduce using rule 33 (operador -> EQUAL .)
    FALSE           reduce using rule 33 (operador -> EQUAL .)
    LPAREN          reduce using rule 33 (operador -> EQUAL .)
    NOT             reduce using rule 33 (operador -> EQUAL .)
    PLUS            reduce using rule 33 (operador -> EQUAL .)
    MINUS           reduce using rule 33 (operador -> EQUAL .)


state 84

    (34) operador -> NEQUAL .

    NUMBER          reduce using rule 34 (operador -> NEQUAL .)
    NOME            reduce using rule 34 (operador -> NEQUAL .)
    CHARACTER       reduce using rule 34 (operador -> NEQUAL .)
    TRUE            reduce using rule 34 (operador -> NEQUAL .)
    FALSE           reduce using rule 34 (operador -> NEQUAL .)
    LPAREN          reduce using rule 34 (operador -> NEQUAL .)
    NOT             reduce using rule 34 (operador -> NEQUAL .)
    PLUS            reduce using rule 34 (operador -> NEQUAL .)
    MINUS           reduce using rule 34 (operador -> NEQUAL .)


state 85

    (35) operador -> GT .

    NUMBER          reduce using rule 35 (operador -> GT .)
    NOME            reduce using rule 35 (operador -> GT .)
    CHARACTER       reduce using rule 35 (operador -> GT .)
    TRUE            reduce using rule 35 (operador -> GT .)
    FALSE           reduce using rule 35 (operador -> GT .)
    LPAREN          reduce using rule 35 (operador -> GT .)
    NOT             reduce using rule 35 (operador -> GT .)
    PLUS            reduce using rule 35 (operador -> GT .)
    MINUS           reduce using rule 35 (operador -> GT .)


state 86

    (36) operador -> LT .

    NUMBER          reduce using rule 36 (operador -> LT .)
    NOME            reduce using rule 36 (operador -> LT .)
    CHARACTER       reduce using rule 36 (operador -> LT .)
    TRUE            reduce using rule 36 (operador -> LT .)
    FALSE           reduce using rule 36 (operador -> LT .)
    LPAREN          reduce using rule 36 (operador -> LT .)
    NOT             reduce using rule 36 (operador -> LT .)
    PLUS            reduce using rule 36 (operador -> LT .)
    MINUS           reduce using rule 36 (operador -> LT .)


state 87

    (37) operador -> GTE .

    NUMBER          reduce using rule 37 (operador -> GTE .)
    NOME            reduce using rule 37 (operador -> GTE .)
    CHARACTER       reduce using rule 37 (operador -> GTE .)
    TRUE            reduce using rule 37 (operador -> GTE .)
    FALSE           reduce using rule 37 (operador -> GTE .)
    LPAREN          reduce using rule 37 (operador -> GTE .)
    NOT             reduce using rule 37 (operador -> GTE .)
    PLUS            reduce using rule 37 (operador -> GTE .)
    MINUS           reduce using rule 37 (operador -> GTE .)


state 88

    (38) operador -> LTE .

    NUMBER          reduce using rule 38 (operador -> LTE .)
    NOME            reduce using rule 38 (operador -> LTE .)
    CHARACTER       reduce using rule 38 (operador -> LTE .)
    TRUE            reduce using rule 38 (operador -> LTE .)
    FALSE           reduce using rule 38 (operador -> LTE .)
    LPAREN          reduce using rule 38 (operador -> LTE .)
    NOT             reduce using rule 38 (operador -> LTE .)
    PLUS            reduce using rule 38 (operador -> LTE .)
    MINUS           reduce using rule 38 (operador -> LTE .)


state 89

    (39) operador -> AND .

    NUMBER          reduce using rule 39 (operador -> AND .)
    NOME            reduce using rule 39 (operador -> AND .)
    CHARACTER       reduce using rule 39 (operador -> AND .)
    TRUE            reduce using rule 39 (operador -> AND .)
    FALSE           reduce using rule 39 (operador -> AND .)
    LPAREN          reduce using rule 39 (operador -> AND .)
    NOT             reduce using rule 39 (operador -> AND .)
    PLUS            reduce using rule 39 (operador -> AND .)
    MINUS           reduce using rule 39 (operador -> AND .)


state 90

    (40) operador -> OR .

    NUMBER          reduce using rule 40 (operador -> OR .)
    NOME            reduce using rule 40 (operador -> OR .)
    CHARACTER       reduce using rule 40 (operador -> OR .)
    TRUE            reduce using rule 40 (operador -> OR .)
    FALSE           reduce using rule 40 (operador -> OR .)
    LPAREN          reduce using rule 40 (operador -> OR .)
    NOT             reduce using rule 40 (operador -> OR .)
    PLUS            reduce using rule 40 (operador -> OR .)
    MINUS           reduce using rule 40 (operador -> OR .)


state 91

    (49) valor -> sinal valor .
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 49 (valor -> sinal valor .)
    COMMA           reduce using rule 49 (valor -> sinal valor .)
    RPAREN          reduce using rule 49 (valor -> sinal valor .)
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

  ! MULTIPLY        [ reduce using rule 49 (valor -> sinal valor .) ]
  ! DIV             [ reduce using rule 49 (valor -> sinal valor .) ]
  ! MOD             [ reduce using rule 49 (valor -> sinal valor .) ]
  ! PLUS            [ reduce using rule 49 (valor -> sinal valor .) ]
  ! MINUS           [ reduce using rule 49 (valor -> sinal valor .) ]
  ! EQUAL           [ reduce using rule 49 (valor -> sinal valor .) ]
  ! NEQUAL          [ reduce using rule 49 (valor -> sinal valor .) ]
  ! GT              [ reduce using rule 49 (valor -> sinal valor .) ]
  ! LT              [ reduce using rule 49 (valor -> sinal valor .) ]
  ! GTE             [ reduce using rule 49 (valor -> sinal valor .) ]
  ! LTE             [ reduce using rule 49 (valor -> sinal valor .) ]
  ! AND             [ reduce using rule 49 (valor -> sinal valor .) ]
  ! OR              [ reduce using rule 49 (valor -> sinal valor .) ]

    operador                       shift and go to state 77

state 92

    (22) parentheses -> LPAREN valor . RPAREN
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 106
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 93

    (2) sinal -> NOT PLUS .

    NUMBER          reduce using rule 2 (sinal -> NOT PLUS .)
    NOME            reduce using rule 2 (sinal -> NOT PLUS .)
    CHARACTER       reduce using rule 2 (sinal -> NOT PLUS .)
    TRUE            reduce using rule 2 (sinal -> NOT PLUS .)
    FALSE           reduce using rule 2 (sinal -> NOT PLUS .)
    LPAREN          reduce using rule 2 (sinal -> NOT PLUS .)
    NOT             reduce using rule 2 (sinal -> NOT PLUS .)
    PLUS            reduce using rule 2 (sinal -> NOT PLUS .)
    MINUS           reduce using rule 2 (sinal -> NOT PLUS .)


state 94

    (3) sinal -> NOT MINUS .

    NUMBER          reduce using rule 3 (sinal -> NOT MINUS .)
    NOME            reduce using rule 3 (sinal -> NOT MINUS .)
    CHARACTER       reduce using rule 3 (sinal -> NOT MINUS .)
    TRUE            reduce using rule 3 (sinal -> NOT MINUS .)
    FALSE           reduce using rule 3 (sinal -> NOT MINUS .)
    LPAREN          reduce using rule 3 (sinal -> NOT MINUS .)
    NOT             reduce using rule 3 (sinal -> NOT MINUS .)
    PLUS            reduce using rule 3 (sinal -> NOT MINUS .)
    MINUS           reduce using rule 3 (sinal -> NOT MINUS .)


state 95

    (83) printf_statement -> PRINTF LPAREN CHARACTER . COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> PRINTF LPAREN CHARACTER . RPAREN SEMICOLON

    COMMA           shift and go to state 107
    RPAREN          shift and go to state 108


state 96

    (82) scanf_statement -> SCANF LPAREN CHARACTER . COMMA NOME RPAREN SEMICOLON

    COMMA           shift and go to state 109


state 97

    (56) declaration_list -> NOME ASSIGN valor .
    (57) declaration_list -> NOME ASSIGN valor . COMMA declaration_list
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 56 (declaration_list -> NOME ASSIGN valor .)
    COMMA           shift and go to state 110
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 98

    (59) if_statement -> IF LPAREN valor RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 111

state 99

    (60) while_statement -> WHILE LPAREN valor RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 112

state 100

    (61) for_statement -> FOR LPAREN for_init SEMICOLON . for_condition SEMICOLON for_update RPAREN comando
    (72) for_condition -> . assignment
    (73) for_condition -> . valor
    (74) for_condition -> . valor for_comma
    (75) for_condition -> . assignment for_comma
    (76) for_condition -> . empty
    (53) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (88) empty -> .
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NOME            shift and go to state 75
    NUMBER          shift and go to state 49
    CHARACTER       shift and go to state 51
    SEMICOLON       reduce using rule 88 (empty -> .)
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    for_condition                  shift and go to state 113
    assignment                     shift and go to state 114
    valor                          shift and go to state 115
    empty                          shift and go to state 116
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 101

    (66) for_init -> assignment for_comma .

    SEMICOLON       reduce using rule 66 (for_init -> assignment for_comma .)


state 102

    (69) for_comma -> COMMA . assignment
    (70) for_comma -> COMMA . valor SEMICOLON
    (71) for_comma -> COMMA . assignment for_comma
    (53) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NOME            shift and go to state 75
    NUMBER          shift and go to state 49
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    assignment                     shift and go to state 117
    valor                          shift and go to state 118
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 103

    (68) for_init -> declaration for_comma .

    SEMICOLON       reduce using rule 68 (for_init -> declaration for_comma .)


state 104

    (67) for_init -> valor for_comma .

    SEMICOLON       reduce using rule 67 (for_init -> valor for_comma .)


state 105

    (52) operation -> valor operador valor .
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 52 (operation -> valor operador valor .)
    COMMA           reduce using rule 52 (operation -> valor operador valor .)
    RPAREN          reduce using rule 52 (operation -> valor operador valor .)
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

  ! MULTIPLY        [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! DIV             [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! MOD             [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! PLUS            [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! MINUS           [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! EQUAL           [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! NEQUAL          [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! GT              [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! LT              [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! GTE             [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! LTE             [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! AND             [ reduce using rule 52 (operation -> valor operador valor .) ]
  ! OR              [ reduce using rule 52 (operation -> valor operador valor .) ]

    operador                       shift and go to state 77

state 106

    (22) parentheses -> LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MULTIPLY        reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    DIV             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MOD             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    PLUS            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MINUS           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    EQUAL           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    NEQUAL          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    GT              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    LT              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    GTE             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    LTE             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    AND             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    OR              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    COMMA           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    RPAREN          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)


state 107

    (83) printf_statement -> PRINTF LPAREN CHARACTER COMMA . valores RPAREN SEMICOLON
    (50) valores -> . valor
    (51) valores -> . valor COMMA valores
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valores                        shift and go to state 119
    valor                          shift and go to state 120
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 108

    (84) printf_statement -> PRINTF LPAREN CHARACTER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 121


state 109

    (82) scanf_statement -> SCANF LPAREN CHARACTER COMMA . NOME RPAREN SEMICOLON

    NOME            shift and go to state 122


state 110

    (57) declaration_list -> NOME ASSIGN valor COMMA . declaration_list
    (54) declaration_list -> . NOME
    (55) declaration_list -> . NOME declaration_list
    (56) declaration_list -> . NOME ASSIGN valor
    (57) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    NOME            shift and go to state 41

    declaration_list               shift and go to state 123

state 111

    (59) if_statement -> IF LPAREN valor RPAREN bloco .

    NOME            reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    IF              reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    WHILE           reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    FOR             reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    LBRACE          reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    BREAK           reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    CONTINUE        reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    RETURN          reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    PRINTF          reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    SCANF           reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    INT             reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    FLOAT           reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    CHAR            reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    VOID            reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    BOOL            reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)
    RBRACE          reduce using rule 59 (if_statement -> IF LPAREN valor RPAREN bloco .)


state 112

    (60) while_statement -> WHILE LPAREN valor RPAREN bloco .

    NOME            reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    IF              reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    WHILE           reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    FOR             reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    LBRACE          reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    BREAK           reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    CONTINUE        reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    RETURN          reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    PRINTF          reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    SCANF           reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    INT             reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    FLOAT           reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    CHAR            reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    VOID            reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    BOOL            reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    RBRACE          reduce using rule 60 (while_statement -> WHILE LPAREN valor RPAREN bloco .)


state 113

    (61) for_statement -> FOR LPAREN for_init SEMICOLON for_condition . SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 124


state 114

    (72) for_condition -> assignment .
    (75) for_condition -> assignment . for_comma
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 72 (for_condition -> assignment .)
    COMMA           shift and go to state 102

    for_comma                      shift and go to state 125

state 115

    (73) for_condition -> valor .
    (74) for_condition -> valor . for_comma
    (52) operation -> valor . operador valor
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 73 (for_condition -> valor .)
    COMMA           shift and go to state 102
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    for_comma                      shift and go to state 126
    operador                       shift and go to state 77

state 116

    (76) for_condition -> empty .

    SEMICOLON       reduce using rule 76 (for_condition -> empty .)


state 117

    (69) for_comma -> COMMA assignment .
    (71) for_comma -> COMMA assignment . for_comma
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 69 (for_comma -> COMMA assignment .)
    RPAREN          reduce using rule 69 (for_comma -> COMMA assignment .)
    COMMA           shift and go to state 102

    for_comma                      shift and go to state 127

state 118

    (70) for_comma -> COMMA valor . SEMICOLON
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       shift and go to state 128
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 119

    (83) printf_statement -> PRINTF LPAREN CHARACTER COMMA valores . RPAREN SEMICOLON

    RPAREN          shift and go to state 129


state 120

    (50) valores -> valor .
    (51) valores -> valor . COMMA valores
    (52) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          reduce using rule 50 (valores -> valor .)
    COMMA           shift and go to state 130
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    operador                       shift and go to state 77

state 121

    (84) printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .

    NOME            reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    IF              reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    FOR             reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    LBRACE          reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    BREAK           reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    RETURN          reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    PRINTF          reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    SCANF           reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    INT             reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    FLOAT           reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    CHAR            reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    VOID            reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    BOOL            reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)
    RBRACE          reduce using rule 84 (printf_statement -> PRINTF LPAREN CHARACTER RPAREN SEMICOLON .)


state 122

    (82) scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME . RPAREN SEMICOLON

    RPAREN          shift and go to state 131


state 123

    (57) declaration_list -> NOME ASSIGN valor COMMA declaration_list .

    SEMICOLON       reduce using rule 57 (declaration_list -> NOME ASSIGN valor COMMA declaration_list .)


state 124

    (61) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON . for_update RPAREN comando
    (77) for_update -> . assignment
    (78) for_update -> . valor
    (79) for_update -> . valor for_comma
    (80) for_update -> . assignment for_comma
    (81) for_update -> . empty
    (53) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (88) empty -> .
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NOME            shift and go to state 75
    NUMBER          shift and go to state 49
    CHARACTER       shift and go to state 51
    RPAREN          reduce using rule 88 (empty -> .)
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    for_update                     shift and go to state 132
    assignment                     shift and go to state 133
    valor                          shift and go to state 134
    empty                          shift and go to state 135
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 125

    (75) for_condition -> assignment for_comma .

    SEMICOLON       reduce using rule 75 (for_condition -> assignment for_comma .)


state 126

    (74) for_condition -> valor for_comma .

    SEMICOLON       reduce using rule 74 (for_condition -> valor for_comma .)


state 127

    (71) for_comma -> COMMA assignment for_comma .

    SEMICOLON       reduce using rule 71 (for_comma -> COMMA assignment for_comma .)
    RPAREN          reduce using rule 71 (for_comma -> COMMA assignment for_comma .)


state 128

    (70) for_comma -> COMMA valor SEMICOLON .

    SEMICOLON       reduce using rule 70 (for_comma -> COMMA valor SEMICOLON .)
    RPAREN          reduce using rule 70 (for_comma -> COMMA valor SEMICOLON .)


state 129

    (83) printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 136


state 130

    (51) valores -> valor COMMA . valores
    (50) valores -> . valor
    (51) valores -> . valor COMMA valores
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (49) valor -> . sinal valor
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (52) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN
    (2) sinal -> . NOT PLUS
    (3) sinal -> . NOT MINUS
    (4) sinal -> . NOT
    (5) sinal -> . PLUS
    (6) sinal -> . MINUS

    NUMBER          shift and go to state 49
    NOME            shift and go to state 50
    CHARACTER       shift and go to state 51
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LPAREN          shift and go to state 58
    NOT             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61

    valor                          shift and go to state 120
    valores                        shift and go to state 137
    boolean                        shift and go to state 52
    operation                      shift and go to state 53
    parentheses                    shift and go to state 54
    sinal                          shift and go to state 55

state 131

    (82) scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 138


state 132

    (61) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update . RPAREN comando

    RPAREN          shift and go to state 139


state 133

    (77) for_update -> assignment .
    (80) for_update -> assignment . for_comma
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma

    RPAREN          reduce using rule 77 (for_update -> assignment .)
    COMMA           shift and go to state 102

    for_comma                      shift and go to state 140

state 134

    (78) for_update -> valor .
    (79) for_update -> valor . for_comma
    (52) operation -> valor . operador valor
    (69) for_comma -> . COMMA assignment
    (70) for_comma -> . COMMA valor SEMICOLON
    (71) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          reduce using rule 78 (for_update -> valor .)
    COMMA           shift and go to state 102
    MULTIPLY        shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    EQUAL           shift and go to state 83
    NEQUAL          shift and go to state 84
    GT              shift and go to state 85
    LT              shift and go to state 86
    GTE             shift and go to state 87
    LTE             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90

    for_comma                      shift and go to state 141
    operador                       shift and go to state 77

state 135

    (81) for_update -> empty .

    RPAREN          reduce using rule 81 (for_update -> empty .)


state 136

    (83) printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .

    NOME            reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    IF              reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    WHILE           reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    FOR             reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    LBRACE          reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    BREAK           reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    RETURN          reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    PRINTF          reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    SCANF           reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    INT             reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    FLOAT           reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    CHAR            reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    VOID            reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    BOOL            reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)
    RBRACE          reduce using rule 83 (printf_statement -> PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON .)


state 137

    (51) valores -> valor COMMA valores .

    RPAREN          reduce using rule 51 (valores -> valor COMMA valores .)


state 138

    (82) scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .

    NOME            reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    IF              reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    WHILE           reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    FOR             reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    LBRACE          reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    BREAK           reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    RETURN          reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    PRINTF          reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    SCANF           reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    INT             reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    FLOAT           reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    CHAR            reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    VOID            reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    BOOL            reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)
    RBRACE          reduce using rule 82 (scanf_statement -> SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON .)


state 139

    (61) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN . comando
    (7) comando -> . declaration
    (8) comando -> . assignment SEMICOLON
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (58) declaration -> . type declaration_list SEMICOLON
    (53) assignment -> . NOME ASSIGN valor
    (59) if_statement -> . IF LPAREN valor RPAREN bloco
    (60) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (61) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (85) break_statement -> . BREAK SEMICOLON
    (86) continue_statement -> . CONTINUE SEMICOLON
    (87) return_statement -> . RETURN valor SEMICOLON
    (83) printf_statement -> . PRINTF LPAREN CHARACTER COMMA valores RPAREN SEMICOLON
    (84) printf_statement -> . PRINTF LPAREN CHARACTER RPAREN SEMICOLON
    (82) scanf_statement -> . SCANF LPAREN CHARACTER COMMA NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comando                        shift and go to state 142
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 140

    (80) for_update -> assignment for_comma .

    RPAREN          reduce using rule 80 (for_update -> assignment for_comma .)


state 141

    (79) for_update -> valor for_comma .

    RPAREN          reduce using rule 79 (for_update -> valor for_comma .)


state 142

    (61) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .

    NOME            reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    IF              reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    WHILE           reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    FOR             reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    LBRACE          reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    BREAK           reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    CONTINUE        reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    RETURN          reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    PRINTF          reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    SCANF           reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    INT             reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    FLOAT           reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    CHAR            reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    VOID            reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    BOOL            reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    RBRACE          reduce using rule 61 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MULTIPLY in state 91 resolved as shift
WARNING: shift/reduce conflict for DIV in state 91 resolved as shift
WARNING: shift/reduce conflict for MOD in state 91 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 91 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 91 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 91 resolved as shift
WARNING: shift/reduce conflict for GT in state 91 resolved as shift
WARNING: shift/reduce conflict for LT in state 91 resolved as shift
WARNING: shift/reduce conflict for GTE in state 91 resolved as shift
WARNING: shift/reduce conflict for LTE in state 91 resolved as shift
WARNING: shift/reduce conflict for AND in state 91 resolved as shift
WARNING: shift/reduce conflict for OR in state 91 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 105 resolved as shift
WARNING: shift/reduce conflict for DIV in state 105 resolved as shift
WARNING: shift/reduce conflict for MOD in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for GTE in state 105 resolved as shift
WARNING: shift/reduce conflict for LTE in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
