Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT
    ELSE
    LBRACKET
    RBRACKET
    SQUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> INT MAIN LPAREN RPAREN bloco
Rule 2     sinal -> NOT PLUS
Rule 3     sinal -> NOT MINUS
Rule 4     sinal -> NOT
Rule 5     sinal -> PLUS
Rule 6     sinal -> MINUS
Rule 7     comando -> declaration
Rule 8     comando -> assignment
Rule 9     comando -> if_statement
Rule 10    comando -> while_statement
Rule 11    comando -> for_statement
Rule 12    comando -> bloco
Rule 13    comando -> break_statement
Rule 14    comando -> continue_statement
Rule 15    comando -> return_statement
Rule 16    comando -> printf_statement
Rule 17    comando -> scanf_statement
Rule 18    comandos -> comando comandos
Rule 19    comandos -> comando
Rule 20    bloco -> LBRACE comandos RBRACE
Rule 21    bloco -> LBRACE RBRACE
Rule 22    parentheses -> LPAREN valor RPAREN
Rule 23    type -> INT
Rule 24    type -> FLOAT
Rule 25    type -> CHAR
Rule 26    type -> VOID
Rule 27    type -> BOOL
Rule 28    operador -> MULTIPLY
Rule 29    operador -> DIV
Rule 30    operador -> MOD
Rule 31    operador -> PLUS
Rule 32    operador -> MINUS
Rule 33    operador -> EQUAL
Rule 34    operador -> NEQUAL
Rule 35    operador -> GT
Rule 36    operador -> LT
Rule 37    operador -> GTE
Rule 38    operador -> LTE
Rule 39    operador -> AND
Rule 40    operador -> OR
Rule 41    boolean -> TRUE
Rule 42    boolean -> FALSE
Rule 43    valor -> NUMBER
Rule 44    valor -> NOME
Rule 45    valor -> CHARACTER
Rule 46    valor -> boolean
Rule 47    valor -> operation
Rule 48    valor -> parentheses
Rule 49    operation -> valor operador valor
Rule 50    assignment -> NOME ASSIGN valor
Rule 51    declaration_list -> NOME
Rule 52    declaration_list -> NOME declaration_list
Rule 53    declaration_list -> NOME ASSIGN valor
Rule 54    declaration_list -> NOME ASSIGN valor COMMA declaration_list
Rule 55    declaration -> type declaration_list SEMICOLON
Rule 56    if_statement -> IF LPAREN valor RPAREN bloco
Rule 57    while_statement -> WHILE LPAREN valor RPAREN bloco
Rule 58    for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
Rule 59    for_init -> assignment
Rule 60    for_init -> declaration
Rule 61    for_init -> valor
Rule 62    for_init -> empty
Rule 63    for_init -> assignment for_comma
Rule 64    for_init -> valor for_comma
Rule 65    for_init -> declaration for_comma
Rule 66    for_comma -> COMMA assignment
Rule 67    for_comma -> COMMA valor SEMICOLON
Rule 68    for_comma -> COMMA assignment for_comma
Rule 69    for_condition -> assignment
Rule 70    for_condition -> valor
Rule 71    for_condition -> valor for_comma
Rule 72    for_condition -> assignment for_comma
Rule 73    for_condition -> empty
Rule 74    for_update -> assignment
Rule 75    for_update -> valor
Rule 76    for_update -> valor for_comma
Rule 77    for_update -> assignment for_comma
Rule 78    for_update -> empty
Rule 79    scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON
Rule 80    printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON
Rule 81    break_statement -> BREAK SEMICOLON
Rule 82    continue_statement -> CONTINUE SEMICOLON
Rule 83    return_statement -> RETURN valor SEMICOLON
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AND                  : 39
ASSIGN               : 50 53 54
BOOL                 : 27
BREAK                : 81
CHAR                 : 25
CHARACTER            : 45
COMMA                : 54 66 67 68
CONTINUE             : 82
DIV                  : 29
DOT                  : 
ELSE                 : 
EQUAL                : 33
FALSE                : 42
FLOAT                : 24
FOR                  : 58
GT                   : 35
GTE                  : 37
IF                   : 56
INT                  : 1 23
LBRACE               : 20 21
LBRACKET             : 
LPAREN               : 1 22 56 57 58 79 80
LT                   : 36
LTE                  : 38
MAIN                 : 1
MINUS                : 3 6 32
MOD                  : 30
MULTIPLY             : 28
NEQUAL               : 34
NOME                 : 44 50 51 52 53 54 79
NOT                  : 2 3 4
NUMBER               : 43
OR                   : 40
PLUS                 : 2 5 31
PRINTF               : 80
RBRACE               : 20 21
RBRACKET             : 
RETURN               : 83
RPAREN               : 1 22 56 57 58 79 80
SCANF                : 79
SEMICOLON            : 55 58 58 67 79 80 81 82 83
SQUOTE               : 
TRUE                 : 41
VOID                 : 26
WHILE                : 57
error                : 

Nonterminals, with rules where they appear

assignment           : 8 59 63 66 68 69 72 74 77
bloco                : 1 12 56 57
boolean              : 46
break_statement      : 13
comando              : 18 19 58
comandos             : 18 20
continue_statement   : 14
declaration          : 7 60 65
declaration_list     : 52 54 55
empty                : 62 73 78
for_comma            : 63 64 65 68 71 72 76 77
for_condition        : 58
for_init             : 58
for_statement        : 11
for_update           : 58
if_statement         : 9
operador             : 49
operation            : 47
parentheses          : 48
printf_statement     : 16
program              : 0
return_statement     : 15
scanf_statement      : 17
sinal                : 
type                 : 55
valor                : 22 49 49 50 53 54 56 57 61 64 67 70 71 75 76 80 83
while_statement      : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INT MAIN LPAREN RPAREN bloco

    INT             shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> INT . MAIN LPAREN RPAREN bloco

    MAIN            shift and go to state 3


state 3

    (1) program -> INT MAIN . LPAREN RPAREN bloco

    LPAREN          shift and go to state 4


state 4

    (1) program -> INT MAIN LPAREN . RPAREN bloco

    RPAREN          shift and go to state 5


state 5

    (1) program -> INT MAIN LPAREN RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 6

state 6

    (1) program -> INT MAIN LPAREN RPAREN bloco .

    $end            reduce using rule 1 (program -> INT MAIN LPAREN RPAREN bloco .)


state 7

    (20) bloco -> LBRACE . comandos RBRACE
    (21) bloco -> LBRACE . RBRACE
    (18) comandos -> . comando comandos
    (19) comandos -> . comando
    (7) comando -> . declaration
    (8) comando -> . assignment
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (55) declaration -> . type declaration_list SEMICOLON
    (50) assignment -> . NOME ASSIGN valor
    (56) if_statement -> . IF LPAREN valor RPAREN bloco
    (57) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (58) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (81) break_statement -> . BREAK SEMICOLON
    (82) continue_statement -> . CONTINUE SEMICOLON
    (83) return_statement -> . RETURN valor SEMICOLON
    (80) printf_statement -> . PRINTF LPAREN valor RPAREN SEMICOLON
    (79) scanf_statement -> . SCANF LPAREN NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    RBRACE          shift and go to state 9
    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comandos                       shift and go to state 8
    comando                        shift and go to state 10
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 8

    (20) bloco -> LBRACE comandos . RBRACE

    RBRACE          shift and go to state 37


state 9

    (21) bloco -> LBRACE RBRACE .

    $end            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    NOME            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    IF              reduce using rule 21 (bloco -> LBRACE RBRACE .)
    WHILE           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    FOR             reduce using rule 21 (bloco -> LBRACE RBRACE .)
    LBRACE          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    BREAK           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    CONTINUE        reduce using rule 21 (bloco -> LBRACE RBRACE .)
    RETURN          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    PRINTF          reduce using rule 21 (bloco -> LBRACE RBRACE .)
    SCANF           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    INT             reduce using rule 21 (bloco -> LBRACE RBRACE .)
    FLOAT           reduce using rule 21 (bloco -> LBRACE RBRACE .)
    CHAR            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    VOID            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    BOOL            reduce using rule 21 (bloco -> LBRACE RBRACE .)
    RBRACE          reduce using rule 21 (bloco -> LBRACE RBRACE .)


state 10

    (18) comandos -> comando . comandos
    (19) comandos -> comando .
    (18) comandos -> . comando comandos
    (19) comandos -> . comando
    (7) comando -> . declaration
    (8) comando -> . assignment
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (55) declaration -> . type declaration_list SEMICOLON
    (50) assignment -> . NOME ASSIGN valor
    (56) if_statement -> . IF LPAREN valor RPAREN bloco
    (57) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (58) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (81) break_statement -> . BREAK SEMICOLON
    (82) continue_statement -> . CONTINUE SEMICOLON
    (83) return_statement -> . RETURN valor SEMICOLON
    (80) printf_statement -> . PRINTF LPAREN valor RPAREN SEMICOLON
    (79) scanf_statement -> . SCANF LPAREN NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    RBRACE          reduce using rule 19 (comandos -> comando .)
    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comando                        shift and go to state 10
    comandos                       shift and go to state 38
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 11

    (7) comando -> declaration .

    NOME            reduce using rule 7 (comando -> declaration .)
    IF              reduce using rule 7 (comando -> declaration .)
    WHILE           reduce using rule 7 (comando -> declaration .)
    FOR             reduce using rule 7 (comando -> declaration .)
    LBRACE          reduce using rule 7 (comando -> declaration .)
    BREAK           reduce using rule 7 (comando -> declaration .)
    CONTINUE        reduce using rule 7 (comando -> declaration .)
    RETURN          reduce using rule 7 (comando -> declaration .)
    PRINTF          reduce using rule 7 (comando -> declaration .)
    SCANF           reduce using rule 7 (comando -> declaration .)
    INT             reduce using rule 7 (comando -> declaration .)
    FLOAT           reduce using rule 7 (comando -> declaration .)
    CHAR            reduce using rule 7 (comando -> declaration .)
    VOID            reduce using rule 7 (comando -> declaration .)
    BOOL            reduce using rule 7 (comando -> declaration .)
    RBRACE          reduce using rule 7 (comando -> declaration .)


state 12

    (8) comando -> assignment .

    NOME            reduce using rule 8 (comando -> assignment .)
    IF              reduce using rule 8 (comando -> assignment .)
    WHILE           reduce using rule 8 (comando -> assignment .)
    FOR             reduce using rule 8 (comando -> assignment .)
    LBRACE          reduce using rule 8 (comando -> assignment .)
    BREAK           reduce using rule 8 (comando -> assignment .)
    CONTINUE        reduce using rule 8 (comando -> assignment .)
    RETURN          reduce using rule 8 (comando -> assignment .)
    PRINTF          reduce using rule 8 (comando -> assignment .)
    SCANF           reduce using rule 8 (comando -> assignment .)
    INT             reduce using rule 8 (comando -> assignment .)
    FLOAT           reduce using rule 8 (comando -> assignment .)
    CHAR            reduce using rule 8 (comando -> assignment .)
    VOID            reduce using rule 8 (comando -> assignment .)
    BOOL            reduce using rule 8 (comando -> assignment .)
    RBRACE          reduce using rule 8 (comando -> assignment .)


state 13

    (9) comando -> if_statement .

    NOME            reduce using rule 9 (comando -> if_statement .)
    IF              reduce using rule 9 (comando -> if_statement .)
    WHILE           reduce using rule 9 (comando -> if_statement .)
    FOR             reduce using rule 9 (comando -> if_statement .)
    LBRACE          reduce using rule 9 (comando -> if_statement .)
    BREAK           reduce using rule 9 (comando -> if_statement .)
    CONTINUE        reduce using rule 9 (comando -> if_statement .)
    RETURN          reduce using rule 9 (comando -> if_statement .)
    PRINTF          reduce using rule 9 (comando -> if_statement .)
    SCANF           reduce using rule 9 (comando -> if_statement .)
    INT             reduce using rule 9 (comando -> if_statement .)
    FLOAT           reduce using rule 9 (comando -> if_statement .)
    CHAR            reduce using rule 9 (comando -> if_statement .)
    VOID            reduce using rule 9 (comando -> if_statement .)
    BOOL            reduce using rule 9 (comando -> if_statement .)
    RBRACE          reduce using rule 9 (comando -> if_statement .)


state 14

    (10) comando -> while_statement .

    NOME            reduce using rule 10 (comando -> while_statement .)
    IF              reduce using rule 10 (comando -> while_statement .)
    WHILE           reduce using rule 10 (comando -> while_statement .)
    FOR             reduce using rule 10 (comando -> while_statement .)
    LBRACE          reduce using rule 10 (comando -> while_statement .)
    BREAK           reduce using rule 10 (comando -> while_statement .)
    CONTINUE        reduce using rule 10 (comando -> while_statement .)
    RETURN          reduce using rule 10 (comando -> while_statement .)
    PRINTF          reduce using rule 10 (comando -> while_statement .)
    SCANF           reduce using rule 10 (comando -> while_statement .)
    INT             reduce using rule 10 (comando -> while_statement .)
    FLOAT           reduce using rule 10 (comando -> while_statement .)
    CHAR            reduce using rule 10 (comando -> while_statement .)
    VOID            reduce using rule 10 (comando -> while_statement .)
    BOOL            reduce using rule 10 (comando -> while_statement .)
    RBRACE          reduce using rule 10 (comando -> while_statement .)


state 15

    (11) comando -> for_statement .

    NOME            reduce using rule 11 (comando -> for_statement .)
    IF              reduce using rule 11 (comando -> for_statement .)
    WHILE           reduce using rule 11 (comando -> for_statement .)
    FOR             reduce using rule 11 (comando -> for_statement .)
    LBRACE          reduce using rule 11 (comando -> for_statement .)
    BREAK           reduce using rule 11 (comando -> for_statement .)
    CONTINUE        reduce using rule 11 (comando -> for_statement .)
    RETURN          reduce using rule 11 (comando -> for_statement .)
    PRINTF          reduce using rule 11 (comando -> for_statement .)
    SCANF           reduce using rule 11 (comando -> for_statement .)
    INT             reduce using rule 11 (comando -> for_statement .)
    FLOAT           reduce using rule 11 (comando -> for_statement .)
    CHAR            reduce using rule 11 (comando -> for_statement .)
    VOID            reduce using rule 11 (comando -> for_statement .)
    BOOL            reduce using rule 11 (comando -> for_statement .)
    RBRACE          reduce using rule 11 (comando -> for_statement .)


state 16

    (12) comando -> bloco .

    NOME            reduce using rule 12 (comando -> bloco .)
    IF              reduce using rule 12 (comando -> bloco .)
    WHILE           reduce using rule 12 (comando -> bloco .)
    FOR             reduce using rule 12 (comando -> bloco .)
    LBRACE          reduce using rule 12 (comando -> bloco .)
    BREAK           reduce using rule 12 (comando -> bloco .)
    CONTINUE        reduce using rule 12 (comando -> bloco .)
    RETURN          reduce using rule 12 (comando -> bloco .)
    PRINTF          reduce using rule 12 (comando -> bloco .)
    SCANF           reduce using rule 12 (comando -> bloco .)
    INT             reduce using rule 12 (comando -> bloco .)
    FLOAT           reduce using rule 12 (comando -> bloco .)
    CHAR            reduce using rule 12 (comando -> bloco .)
    VOID            reduce using rule 12 (comando -> bloco .)
    BOOL            reduce using rule 12 (comando -> bloco .)
    RBRACE          reduce using rule 12 (comando -> bloco .)


state 17

    (13) comando -> break_statement .

    NOME            reduce using rule 13 (comando -> break_statement .)
    IF              reduce using rule 13 (comando -> break_statement .)
    WHILE           reduce using rule 13 (comando -> break_statement .)
    FOR             reduce using rule 13 (comando -> break_statement .)
    LBRACE          reduce using rule 13 (comando -> break_statement .)
    BREAK           reduce using rule 13 (comando -> break_statement .)
    CONTINUE        reduce using rule 13 (comando -> break_statement .)
    RETURN          reduce using rule 13 (comando -> break_statement .)
    PRINTF          reduce using rule 13 (comando -> break_statement .)
    SCANF           reduce using rule 13 (comando -> break_statement .)
    INT             reduce using rule 13 (comando -> break_statement .)
    FLOAT           reduce using rule 13 (comando -> break_statement .)
    CHAR            reduce using rule 13 (comando -> break_statement .)
    VOID            reduce using rule 13 (comando -> break_statement .)
    BOOL            reduce using rule 13 (comando -> break_statement .)
    RBRACE          reduce using rule 13 (comando -> break_statement .)


state 18

    (14) comando -> continue_statement .

    NOME            reduce using rule 14 (comando -> continue_statement .)
    IF              reduce using rule 14 (comando -> continue_statement .)
    WHILE           reduce using rule 14 (comando -> continue_statement .)
    FOR             reduce using rule 14 (comando -> continue_statement .)
    LBRACE          reduce using rule 14 (comando -> continue_statement .)
    BREAK           reduce using rule 14 (comando -> continue_statement .)
    CONTINUE        reduce using rule 14 (comando -> continue_statement .)
    RETURN          reduce using rule 14 (comando -> continue_statement .)
    PRINTF          reduce using rule 14 (comando -> continue_statement .)
    SCANF           reduce using rule 14 (comando -> continue_statement .)
    INT             reduce using rule 14 (comando -> continue_statement .)
    FLOAT           reduce using rule 14 (comando -> continue_statement .)
    CHAR            reduce using rule 14 (comando -> continue_statement .)
    VOID            reduce using rule 14 (comando -> continue_statement .)
    BOOL            reduce using rule 14 (comando -> continue_statement .)
    RBRACE          reduce using rule 14 (comando -> continue_statement .)


state 19

    (15) comando -> return_statement .

    NOME            reduce using rule 15 (comando -> return_statement .)
    IF              reduce using rule 15 (comando -> return_statement .)
    WHILE           reduce using rule 15 (comando -> return_statement .)
    FOR             reduce using rule 15 (comando -> return_statement .)
    LBRACE          reduce using rule 15 (comando -> return_statement .)
    BREAK           reduce using rule 15 (comando -> return_statement .)
    CONTINUE        reduce using rule 15 (comando -> return_statement .)
    RETURN          reduce using rule 15 (comando -> return_statement .)
    PRINTF          reduce using rule 15 (comando -> return_statement .)
    SCANF           reduce using rule 15 (comando -> return_statement .)
    INT             reduce using rule 15 (comando -> return_statement .)
    FLOAT           reduce using rule 15 (comando -> return_statement .)
    CHAR            reduce using rule 15 (comando -> return_statement .)
    VOID            reduce using rule 15 (comando -> return_statement .)
    BOOL            reduce using rule 15 (comando -> return_statement .)
    RBRACE          reduce using rule 15 (comando -> return_statement .)


state 20

    (16) comando -> printf_statement .

    NOME            reduce using rule 16 (comando -> printf_statement .)
    IF              reduce using rule 16 (comando -> printf_statement .)
    WHILE           reduce using rule 16 (comando -> printf_statement .)
    FOR             reduce using rule 16 (comando -> printf_statement .)
    LBRACE          reduce using rule 16 (comando -> printf_statement .)
    BREAK           reduce using rule 16 (comando -> printf_statement .)
    CONTINUE        reduce using rule 16 (comando -> printf_statement .)
    RETURN          reduce using rule 16 (comando -> printf_statement .)
    PRINTF          reduce using rule 16 (comando -> printf_statement .)
    SCANF           reduce using rule 16 (comando -> printf_statement .)
    INT             reduce using rule 16 (comando -> printf_statement .)
    FLOAT           reduce using rule 16 (comando -> printf_statement .)
    CHAR            reduce using rule 16 (comando -> printf_statement .)
    VOID            reduce using rule 16 (comando -> printf_statement .)
    BOOL            reduce using rule 16 (comando -> printf_statement .)
    RBRACE          reduce using rule 16 (comando -> printf_statement .)


state 21

    (17) comando -> scanf_statement .

    NOME            reduce using rule 17 (comando -> scanf_statement .)
    IF              reduce using rule 17 (comando -> scanf_statement .)
    WHILE           reduce using rule 17 (comando -> scanf_statement .)
    FOR             reduce using rule 17 (comando -> scanf_statement .)
    LBRACE          reduce using rule 17 (comando -> scanf_statement .)
    BREAK           reduce using rule 17 (comando -> scanf_statement .)
    CONTINUE        reduce using rule 17 (comando -> scanf_statement .)
    RETURN          reduce using rule 17 (comando -> scanf_statement .)
    PRINTF          reduce using rule 17 (comando -> scanf_statement .)
    SCANF           reduce using rule 17 (comando -> scanf_statement .)
    INT             reduce using rule 17 (comando -> scanf_statement .)
    FLOAT           reduce using rule 17 (comando -> scanf_statement .)
    CHAR            reduce using rule 17 (comando -> scanf_statement .)
    VOID            reduce using rule 17 (comando -> scanf_statement .)
    BOOL            reduce using rule 17 (comando -> scanf_statement .)
    RBRACE          reduce using rule 17 (comando -> scanf_statement .)


state 22

    (55) declaration -> type . declaration_list SEMICOLON
    (51) declaration_list -> . NOME
    (52) declaration_list -> . NOME declaration_list
    (53) declaration_list -> . NOME ASSIGN valor
    (54) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    NOME            shift and go to state 40

    declaration_list               shift and go to state 39

state 23

    (50) assignment -> NOME . ASSIGN valor

    ASSIGN          shift and go to state 41


state 24

    (56) if_statement -> IF . LPAREN valor RPAREN bloco

    LPAREN          shift and go to state 42


state 25

    (57) while_statement -> WHILE . LPAREN valor RPAREN bloco

    LPAREN          shift and go to state 43


state 26

    (58) for_statement -> FOR . LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    LPAREN          shift and go to state 44


state 27

    (81) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 45


state 28

    (82) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 46


state 29

    (83) return_statement -> RETURN . valor SEMICOLON
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 47
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 30

    (80) printf_statement -> PRINTF . LPAREN valor RPAREN SEMICOLON

    LPAREN          shift and go to state 57


state 31

    (79) scanf_statement -> SCANF . LPAREN NOME RPAREN SEMICOLON

    LPAREN          shift and go to state 58


state 32

    (23) type -> INT .

    NOME            reduce using rule 23 (type -> INT .)


state 33

    (24) type -> FLOAT .

    NOME            reduce using rule 24 (type -> FLOAT .)


state 34

    (25) type -> CHAR .

    NOME            reduce using rule 25 (type -> CHAR .)


state 35

    (26) type -> VOID .

    NOME            reduce using rule 26 (type -> VOID .)


state 36

    (27) type -> BOOL .

    NOME            reduce using rule 27 (type -> BOOL .)


state 37

    (20) bloco -> LBRACE comandos RBRACE .

    $end            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    NOME            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    IF              reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    WHILE           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    FOR             reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    LBRACE          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    BREAK           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    CONTINUE        reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    RETURN          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    PRINTF          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    SCANF           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    INT             reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    FLOAT           reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    CHAR            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    VOID            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    BOOL            reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)
    RBRACE          reduce using rule 20 (bloco -> LBRACE comandos RBRACE .)


state 38

    (18) comandos -> comando comandos .

    RBRACE          reduce using rule 18 (comandos -> comando comandos .)


state 39

    (55) declaration -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 59


state 40

    (51) declaration_list -> NOME .
    (52) declaration_list -> NOME . declaration_list
    (53) declaration_list -> NOME . ASSIGN valor
    (54) declaration_list -> NOME . ASSIGN valor COMMA declaration_list
    (51) declaration_list -> . NOME
    (52) declaration_list -> . NOME declaration_list
    (53) declaration_list -> . NOME ASSIGN valor
    (54) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    SEMICOLON       reduce using rule 51 (declaration_list -> NOME .)
    ASSIGN          shift and go to state 61
    NOME            shift and go to state 40

    declaration_list               shift and go to state 60

state 41

    (50) assignment -> NOME ASSIGN . valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 62
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 42

    (56) if_statement -> IF LPAREN . valor RPAREN bloco
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 63
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 43

    (57) while_statement -> WHILE LPAREN . valor RPAREN bloco
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 64
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 44

    (58) for_statement -> FOR LPAREN . for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (59) for_init -> . assignment
    (60) for_init -> . declaration
    (61) for_init -> . valor
    (62) for_init -> . empty
    (63) for_init -> . assignment for_comma
    (64) for_init -> . valor for_comma
    (65) for_init -> . declaration for_comma
    (50) assignment -> . NOME ASSIGN valor
    (55) declaration -> . type declaration_list SEMICOLON
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (84) empty -> .
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 70
    NUMBER          shift and go to state 48
    CHARACTER       shift and go to state 50
    SEMICOLON       reduce using rule 84 (empty -> .)
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    for_init                       shift and go to state 65
    assignment                     shift and go to state 66
    declaration                    shift and go to state 67
    valor                          shift and go to state 68
    empty                          shift and go to state 69
    type                           shift and go to state 22
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 45

    (81) break_statement -> BREAK SEMICOLON .

    NOME            reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    SCANF           reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 81 (break_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 81 (break_statement -> BREAK SEMICOLON .)


state 46

    (82) continue_statement -> CONTINUE SEMICOLON .

    NOME            reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    PRINTF          reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    SCANF           reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 82 (continue_statement -> CONTINUE SEMICOLON .)


state 47

    (83) return_statement -> RETURN valor . SEMICOLON
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       shift and go to state 71
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 48

    (43) valor -> NUMBER .

    SEMICOLON       reduce using rule 43 (valor -> NUMBER .)
    MULTIPLY        reduce using rule 43 (valor -> NUMBER .)
    DIV             reduce using rule 43 (valor -> NUMBER .)
    MOD             reduce using rule 43 (valor -> NUMBER .)
    PLUS            reduce using rule 43 (valor -> NUMBER .)
    MINUS           reduce using rule 43 (valor -> NUMBER .)
    EQUAL           reduce using rule 43 (valor -> NUMBER .)
    NEQUAL          reduce using rule 43 (valor -> NUMBER .)
    GT              reduce using rule 43 (valor -> NUMBER .)
    LT              reduce using rule 43 (valor -> NUMBER .)
    GTE             reduce using rule 43 (valor -> NUMBER .)
    LTE             reduce using rule 43 (valor -> NUMBER .)
    AND             reduce using rule 43 (valor -> NUMBER .)
    OR              reduce using rule 43 (valor -> NUMBER .)
    NOME            reduce using rule 43 (valor -> NUMBER .)
    IF              reduce using rule 43 (valor -> NUMBER .)
    WHILE           reduce using rule 43 (valor -> NUMBER .)
    FOR             reduce using rule 43 (valor -> NUMBER .)
    LBRACE          reduce using rule 43 (valor -> NUMBER .)
    BREAK           reduce using rule 43 (valor -> NUMBER .)
    CONTINUE        reduce using rule 43 (valor -> NUMBER .)
    RETURN          reduce using rule 43 (valor -> NUMBER .)
    PRINTF          reduce using rule 43 (valor -> NUMBER .)
    SCANF           reduce using rule 43 (valor -> NUMBER .)
    INT             reduce using rule 43 (valor -> NUMBER .)
    FLOAT           reduce using rule 43 (valor -> NUMBER .)
    CHAR            reduce using rule 43 (valor -> NUMBER .)
    VOID            reduce using rule 43 (valor -> NUMBER .)
    BOOL            reduce using rule 43 (valor -> NUMBER .)
    RBRACE          reduce using rule 43 (valor -> NUMBER .)
    COMMA           reduce using rule 43 (valor -> NUMBER .)
    RPAREN          reduce using rule 43 (valor -> NUMBER .)


state 49

    (44) valor -> NOME .

    SEMICOLON       reduce using rule 44 (valor -> NOME .)
    MULTIPLY        reduce using rule 44 (valor -> NOME .)
    DIV             reduce using rule 44 (valor -> NOME .)
    MOD             reduce using rule 44 (valor -> NOME .)
    PLUS            reduce using rule 44 (valor -> NOME .)
    MINUS           reduce using rule 44 (valor -> NOME .)
    EQUAL           reduce using rule 44 (valor -> NOME .)
    NEQUAL          reduce using rule 44 (valor -> NOME .)
    GT              reduce using rule 44 (valor -> NOME .)
    LT              reduce using rule 44 (valor -> NOME .)
    GTE             reduce using rule 44 (valor -> NOME .)
    LTE             reduce using rule 44 (valor -> NOME .)
    AND             reduce using rule 44 (valor -> NOME .)
    OR              reduce using rule 44 (valor -> NOME .)
    NOME            reduce using rule 44 (valor -> NOME .)
    IF              reduce using rule 44 (valor -> NOME .)
    WHILE           reduce using rule 44 (valor -> NOME .)
    FOR             reduce using rule 44 (valor -> NOME .)
    LBRACE          reduce using rule 44 (valor -> NOME .)
    BREAK           reduce using rule 44 (valor -> NOME .)
    CONTINUE        reduce using rule 44 (valor -> NOME .)
    RETURN          reduce using rule 44 (valor -> NOME .)
    PRINTF          reduce using rule 44 (valor -> NOME .)
    SCANF           reduce using rule 44 (valor -> NOME .)
    INT             reduce using rule 44 (valor -> NOME .)
    FLOAT           reduce using rule 44 (valor -> NOME .)
    CHAR            reduce using rule 44 (valor -> NOME .)
    VOID            reduce using rule 44 (valor -> NOME .)
    BOOL            reduce using rule 44 (valor -> NOME .)
    RBRACE          reduce using rule 44 (valor -> NOME .)
    COMMA           reduce using rule 44 (valor -> NOME .)
    RPAREN          reduce using rule 44 (valor -> NOME .)


state 50

    (45) valor -> CHARACTER .

    SEMICOLON       reduce using rule 45 (valor -> CHARACTER .)
    MULTIPLY        reduce using rule 45 (valor -> CHARACTER .)
    DIV             reduce using rule 45 (valor -> CHARACTER .)
    MOD             reduce using rule 45 (valor -> CHARACTER .)
    PLUS            reduce using rule 45 (valor -> CHARACTER .)
    MINUS           reduce using rule 45 (valor -> CHARACTER .)
    EQUAL           reduce using rule 45 (valor -> CHARACTER .)
    NEQUAL          reduce using rule 45 (valor -> CHARACTER .)
    GT              reduce using rule 45 (valor -> CHARACTER .)
    LT              reduce using rule 45 (valor -> CHARACTER .)
    GTE             reduce using rule 45 (valor -> CHARACTER .)
    LTE             reduce using rule 45 (valor -> CHARACTER .)
    AND             reduce using rule 45 (valor -> CHARACTER .)
    OR              reduce using rule 45 (valor -> CHARACTER .)
    NOME            reduce using rule 45 (valor -> CHARACTER .)
    IF              reduce using rule 45 (valor -> CHARACTER .)
    WHILE           reduce using rule 45 (valor -> CHARACTER .)
    FOR             reduce using rule 45 (valor -> CHARACTER .)
    LBRACE          reduce using rule 45 (valor -> CHARACTER .)
    BREAK           reduce using rule 45 (valor -> CHARACTER .)
    CONTINUE        reduce using rule 45 (valor -> CHARACTER .)
    RETURN          reduce using rule 45 (valor -> CHARACTER .)
    PRINTF          reduce using rule 45 (valor -> CHARACTER .)
    SCANF           reduce using rule 45 (valor -> CHARACTER .)
    INT             reduce using rule 45 (valor -> CHARACTER .)
    FLOAT           reduce using rule 45 (valor -> CHARACTER .)
    CHAR            reduce using rule 45 (valor -> CHARACTER .)
    VOID            reduce using rule 45 (valor -> CHARACTER .)
    BOOL            reduce using rule 45 (valor -> CHARACTER .)
    RBRACE          reduce using rule 45 (valor -> CHARACTER .)
    COMMA           reduce using rule 45 (valor -> CHARACTER .)
    RPAREN          reduce using rule 45 (valor -> CHARACTER .)


state 51

    (46) valor -> boolean .

    SEMICOLON       reduce using rule 46 (valor -> boolean .)
    MULTIPLY        reduce using rule 46 (valor -> boolean .)
    DIV             reduce using rule 46 (valor -> boolean .)
    MOD             reduce using rule 46 (valor -> boolean .)
    PLUS            reduce using rule 46 (valor -> boolean .)
    MINUS           reduce using rule 46 (valor -> boolean .)
    EQUAL           reduce using rule 46 (valor -> boolean .)
    NEQUAL          reduce using rule 46 (valor -> boolean .)
    GT              reduce using rule 46 (valor -> boolean .)
    LT              reduce using rule 46 (valor -> boolean .)
    GTE             reduce using rule 46 (valor -> boolean .)
    LTE             reduce using rule 46 (valor -> boolean .)
    AND             reduce using rule 46 (valor -> boolean .)
    OR              reduce using rule 46 (valor -> boolean .)
    NOME            reduce using rule 46 (valor -> boolean .)
    IF              reduce using rule 46 (valor -> boolean .)
    WHILE           reduce using rule 46 (valor -> boolean .)
    FOR             reduce using rule 46 (valor -> boolean .)
    LBRACE          reduce using rule 46 (valor -> boolean .)
    BREAK           reduce using rule 46 (valor -> boolean .)
    CONTINUE        reduce using rule 46 (valor -> boolean .)
    RETURN          reduce using rule 46 (valor -> boolean .)
    PRINTF          reduce using rule 46 (valor -> boolean .)
    SCANF           reduce using rule 46 (valor -> boolean .)
    INT             reduce using rule 46 (valor -> boolean .)
    FLOAT           reduce using rule 46 (valor -> boolean .)
    CHAR            reduce using rule 46 (valor -> boolean .)
    VOID            reduce using rule 46 (valor -> boolean .)
    BOOL            reduce using rule 46 (valor -> boolean .)
    RBRACE          reduce using rule 46 (valor -> boolean .)
    COMMA           reduce using rule 46 (valor -> boolean .)
    RPAREN          reduce using rule 46 (valor -> boolean .)


state 52

    (47) valor -> operation .

    SEMICOLON       reduce using rule 47 (valor -> operation .)
    MULTIPLY        reduce using rule 47 (valor -> operation .)
    DIV             reduce using rule 47 (valor -> operation .)
    MOD             reduce using rule 47 (valor -> operation .)
    PLUS            reduce using rule 47 (valor -> operation .)
    MINUS           reduce using rule 47 (valor -> operation .)
    EQUAL           reduce using rule 47 (valor -> operation .)
    NEQUAL          reduce using rule 47 (valor -> operation .)
    GT              reduce using rule 47 (valor -> operation .)
    LT              reduce using rule 47 (valor -> operation .)
    GTE             reduce using rule 47 (valor -> operation .)
    LTE             reduce using rule 47 (valor -> operation .)
    AND             reduce using rule 47 (valor -> operation .)
    OR              reduce using rule 47 (valor -> operation .)
    NOME            reduce using rule 47 (valor -> operation .)
    IF              reduce using rule 47 (valor -> operation .)
    WHILE           reduce using rule 47 (valor -> operation .)
    FOR             reduce using rule 47 (valor -> operation .)
    LBRACE          reduce using rule 47 (valor -> operation .)
    BREAK           reduce using rule 47 (valor -> operation .)
    CONTINUE        reduce using rule 47 (valor -> operation .)
    RETURN          reduce using rule 47 (valor -> operation .)
    PRINTF          reduce using rule 47 (valor -> operation .)
    SCANF           reduce using rule 47 (valor -> operation .)
    INT             reduce using rule 47 (valor -> operation .)
    FLOAT           reduce using rule 47 (valor -> operation .)
    CHAR            reduce using rule 47 (valor -> operation .)
    VOID            reduce using rule 47 (valor -> operation .)
    BOOL            reduce using rule 47 (valor -> operation .)
    RBRACE          reduce using rule 47 (valor -> operation .)
    COMMA           reduce using rule 47 (valor -> operation .)
    RPAREN          reduce using rule 47 (valor -> operation .)


state 53

    (48) valor -> parentheses .

    SEMICOLON       reduce using rule 48 (valor -> parentheses .)
    MULTIPLY        reduce using rule 48 (valor -> parentheses .)
    DIV             reduce using rule 48 (valor -> parentheses .)
    MOD             reduce using rule 48 (valor -> parentheses .)
    PLUS            reduce using rule 48 (valor -> parentheses .)
    MINUS           reduce using rule 48 (valor -> parentheses .)
    EQUAL           reduce using rule 48 (valor -> parentheses .)
    NEQUAL          reduce using rule 48 (valor -> parentheses .)
    GT              reduce using rule 48 (valor -> parentheses .)
    LT              reduce using rule 48 (valor -> parentheses .)
    GTE             reduce using rule 48 (valor -> parentheses .)
    LTE             reduce using rule 48 (valor -> parentheses .)
    AND             reduce using rule 48 (valor -> parentheses .)
    OR              reduce using rule 48 (valor -> parentheses .)
    NOME            reduce using rule 48 (valor -> parentheses .)
    IF              reduce using rule 48 (valor -> parentheses .)
    WHILE           reduce using rule 48 (valor -> parentheses .)
    FOR             reduce using rule 48 (valor -> parentheses .)
    LBRACE          reduce using rule 48 (valor -> parentheses .)
    BREAK           reduce using rule 48 (valor -> parentheses .)
    CONTINUE        reduce using rule 48 (valor -> parentheses .)
    RETURN          reduce using rule 48 (valor -> parentheses .)
    PRINTF          reduce using rule 48 (valor -> parentheses .)
    SCANF           reduce using rule 48 (valor -> parentheses .)
    INT             reduce using rule 48 (valor -> parentheses .)
    FLOAT           reduce using rule 48 (valor -> parentheses .)
    CHAR            reduce using rule 48 (valor -> parentheses .)
    VOID            reduce using rule 48 (valor -> parentheses .)
    BOOL            reduce using rule 48 (valor -> parentheses .)
    RBRACE          reduce using rule 48 (valor -> parentheses .)
    COMMA           reduce using rule 48 (valor -> parentheses .)
    RPAREN          reduce using rule 48 (valor -> parentheses .)


state 54

    (41) boolean -> TRUE .

    SEMICOLON       reduce using rule 41 (boolean -> TRUE .)
    MULTIPLY        reduce using rule 41 (boolean -> TRUE .)
    DIV             reduce using rule 41 (boolean -> TRUE .)
    MOD             reduce using rule 41 (boolean -> TRUE .)
    PLUS            reduce using rule 41 (boolean -> TRUE .)
    MINUS           reduce using rule 41 (boolean -> TRUE .)
    EQUAL           reduce using rule 41 (boolean -> TRUE .)
    NEQUAL          reduce using rule 41 (boolean -> TRUE .)
    GT              reduce using rule 41 (boolean -> TRUE .)
    LT              reduce using rule 41 (boolean -> TRUE .)
    GTE             reduce using rule 41 (boolean -> TRUE .)
    LTE             reduce using rule 41 (boolean -> TRUE .)
    AND             reduce using rule 41 (boolean -> TRUE .)
    OR              reduce using rule 41 (boolean -> TRUE .)
    NOME            reduce using rule 41 (boolean -> TRUE .)
    IF              reduce using rule 41 (boolean -> TRUE .)
    WHILE           reduce using rule 41 (boolean -> TRUE .)
    FOR             reduce using rule 41 (boolean -> TRUE .)
    LBRACE          reduce using rule 41 (boolean -> TRUE .)
    BREAK           reduce using rule 41 (boolean -> TRUE .)
    CONTINUE        reduce using rule 41 (boolean -> TRUE .)
    RETURN          reduce using rule 41 (boolean -> TRUE .)
    PRINTF          reduce using rule 41 (boolean -> TRUE .)
    SCANF           reduce using rule 41 (boolean -> TRUE .)
    INT             reduce using rule 41 (boolean -> TRUE .)
    FLOAT           reduce using rule 41 (boolean -> TRUE .)
    CHAR            reduce using rule 41 (boolean -> TRUE .)
    VOID            reduce using rule 41 (boolean -> TRUE .)
    BOOL            reduce using rule 41 (boolean -> TRUE .)
    RBRACE          reduce using rule 41 (boolean -> TRUE .)
    COMMA           reduce using rule 41 (boolean -> TRUE .)
    RPAREN          reduce using rule 41 (boolean -> TRUE .)


state 55

    (42) boolean -> FALSE .

    SEMICOLON       reduce using rule 42 (boolean -> FALSE .)
    MULTIPLY        reduce using rule 42 (boolean -> FALSE .)
    DIV             reduce using rule 42 (boolean -> FALSE .)
    MOD             reduce using rule 42 (boolean -> FALSE .)
    PLUS            reduce using rule 42 (boolean -> FALSE .)
    MINUS           reduce using rule 42 (boolean -> FALSE .)
    EQUAL           reduce using rule 42 (boolean -> FALSE .)
    NEQUAL          reduce using rule 42 (boolean -> FALSE .)
    GT              reduce using rule 42 (boolean -> FALSE .)
    LT              reduce using rule 42 (boolean -> FALSE .)
    GTE             reduce using rule 42 (boolean -> FALSE .)
    LTE             reduce using rule 42 (boolean -> FALSE .)
    AND             reduce using rule 42 (boolean -> FALSE .)
    OR              reduce using rule 42 (boolean -> FALSE .)
    NOME            reduce using rule 42 (boolean -> FALSE .)
    IF              reduce using rule 42 (boolean -> FALSE .)
    WHILE           reduce using rule 42 (boolean -> FALSE .)
    FOR             reduce using rule 42 (boolean -> FALSE .)
    LBRACE          reduce using rule 42 (boolean -> FALSE .)
    BREAK           reduce using rule 42 (boolean -> FALSE .)
    CONTINUE        reduce using rule 42 (boolean -> FALSE .)
    RETURN          reduce using rule 42 (boolean -> FALSE .)
    PRINTF          reduce using rule 42 (boolean -> FALSE .)
    SCANF           reduce using rule 42 (boolean -> FALSE .)
    INT             reduce using rule 42 (boolean -> FALSE .)
    FLOAT           reduce using rule 42 (boolean -> FALSE .)
    CHAR            reduce using rule 42 (boolean -> FALSE .)
    VOID            reduce using rule 42 (boolean -> FALSE .)
    BOOL            reduce using rule 42 (boolean -> FALSE .)
    RBRACE          reduce using rule 42 (boolean -> FALSE .)
    COMMA           reduce using rule 42 (boolean -> FALSE .)
    RPAREN          reduce using rule 42 (boolean -> FALSE .)


state 56

    (22) parentheses -> LPAREN . valor RPAREN
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 86
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 57

    (80) printf_statement -> PRINTF LPAREN . valor RPAREN SEMICOLON
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 87
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 58

    (79) scanf_statement -> SCANF LPAREN . NOME RPAREN SEMICOLON

    NOME            shift and go to state 88


state 59

    (55) declaration -> type declaration_list SEMICOLON .

    NOME            reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    IF              reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    WHILE           reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    FOR             reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    LBRACE          reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    BREAK           reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    CONTINUE        reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    RETURN          reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    PRINTF          reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    SCANF           reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    INT             reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    FLOAT           reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    CHAR            reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    VOID            reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    BOOL            reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    COMMA           reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)
    SEMICOLON       reduce using rule 55 (declaration -> type declaration_list SEMICOLON .)


state 60

    (52) declaration_list -> NOME declaration_list .

    SEMICOLON       reduce using rule 52 (declaration_list -> NOME declaration_list .)


state 61

    (53) declaration_list -> NOME ASSIGN . valor
    (54) declaration_list -> NOME ASSIGN . valor COMMA declaration_list
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 89
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 62

    (50) assignment -> NOME ASSIGN valor .
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    NOME            reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    IF              reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    WHILE           reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    FOR             reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    LBRACE          reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    BREAK           reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    CONTINUE        reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    RETURN          reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    PRINTF          reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    SCANF           reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    INT             reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    FLOAT           reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    CHAR            reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    VOID            reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    BOOL            reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    RBRACE          reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    COMMA           reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    SEMICOLON       reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    RPAREN          reduce using rule 50 (assignment -> NOME ASSIGN valor .)
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 63

    (56) if_statement -> IF LPAREN valor . RPAREN bloco
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 90
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 64

    (57) while_statement -> WHILE LPAREN valor . RPAREN bloco
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 91
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 65

    (58) for_statement -> FOR LPAREN for_init . SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 92


state 66

    (59) for_init -> assignment .
    (63) for_init -> assignment . for_comma
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 59 (for_init -> assignment .)
    COMMA           shift and go to state 94

    for_comma                      shift and go to state 93

state 67

    (60) for_init -> declaration .
    (65) for_init -> declaration . for_comma
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 60 (for_init -> declaration .)
    COMMA           shift and go to state 94

    for_comma                      shift and go to state 95

state 68

    (61) for_init -> valor .
    (64) for_init -> valor . for_comma
    (49) operation -> valor . operador valor
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 61 (for_init -> valor .)
    COMMA           shift and go to state 94
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    for_comma                      shift and go to state 96
    operador                       shift and go to state 72

state 69

    (62) for_init -> empty .

    SEMICOLON       reduce using rule 62 (for_init -> empty .)


state 70

    (50) assignment -> NOME . ASSIGN valor
    (44) valor -> NOME .

    ASSIGN          shift and go to state 41
    COMMA           reduce using rule 44 (valor -> NOME .)
    MULTIPLY        reduce using rule 44 (valor -> NOME .)
    DIV             reduce using rule 44 (valor -> NOME .)
    MOD             reduce using rule 44 (valor -> NOME .)
    PLUS            reduce using rule 44 (valor -> NOME .)
    MINUS           reduce using rule 44 (valor -> NOME .)
    EQUAL           reduce using rule 44 (valor -> NOME .)
    NEQUAL          reduce using rule 44 (valor -> NOME .)
    GT              reduce using rule 44 (valor -> NOME .)
    LT              reduce using rule 44 (valor -> NOME .)
    GTE             reduce using rule 44 (valor -> NOME .)
    LTE             reduce using rule 44 (valor -> NOME .)
    AND             reduce using rule 44 (valor -> NOME .)
    OR              reduce using rule 44 (valor -> NOME .)
    SEMICOLON       reduce using rule 44 (valor -> NOME .)
    RPAREN          reduce using rule 44 (valor -> NOME .)


state 71

    (83) return_statement -> RETURN valor SEMICOLON .

    NOME            reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    IF              reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    WHILE           reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    FOR             reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    LBRACE          reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    BREAK           reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    CONTINUE        reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    RETURN          reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    PRINTF          reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    SCANF           reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    INT             reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    FLOAT           reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    CHAR            reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    VOID            reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    BOOL            reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)
    RBRACE          reduce using rule 83 (return_statement -> RETURN valor SEMICOLON .)


state 72

    (49) operation -> valor operador . valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 48
    NOME            shift and go to state 49
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    valor                          shift and go to state 97
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 73

    (28) operador -> MULTIPLY .

    NUMBER          reduce using rule 28 (operador -> MULTIPLY .)
    NOME            reduce using rule 28 (operador -> MULTIPLY .)
    CHARACTER       reduce using rule 28 (operador -> MULTIPLY .)
    TRUE            reduce using rule 28 (operador -> MULTIPLY .)
    FALSE           reduce using rule 28 (operador -> MULTIPLY .)
    LPAREN          reduce using rule 28 (operador -> MULTIPLY .)


state 74

    (29) operador -> DIV .

    NUMBER          reduce using rule 29 (operador -> DIV .)
    NOME            reduce using rule 29 (operador -> DIV .)
    CHARACTER       reduce using rule 29 (operador -> DIV .)
    TRUE            reduce using rule 29 (operador -> DIV .)
    FALSE           reduce using rule 29 (operador -> DIV .)
    LPAREN          reduce using rule 29 (operador -> DIV .)


state 75

    (30) operador -> MOD .

    NUMBER          reduce using rule 30 (operador -> MOD .)
    NOME            reduce using rule 30 (operador -> MOD .)
    CHARACTER       reduce using rule 30 (operador -> MOD .)
    TRUE            reduce using rule 30 (operador -> MOD .)
    FALSE           reduce using rule 30 (operador -> MOD .)
    LPAREN          reduce using rule 30 (operador -> MOD .)


state 76

    (31) operador -> PLUS .

    NUMBER          reduce using rule 31 (operador -> PLUS .)
    NOME            reduce using rule 31 (operador -> PLUS .)
    CHARACTER       reduce using rule 31 (operador -> PLUS .)
    TRUE            reduce using rule 31 (operador -> PLUS .)
    FALSE           reduce using rule 31 (operador -> PLUS .)
    LPAREN          reduce using rule 31 (operador -> PLUS .)


state 77

    (32) operador -> MINUS .

    NUMBER          reduce using rule 32 (operador -> MINUS .)
    NOME            reduce using rule 32 (operador -> MINUS .)
    CHARACTER       reduce using rule 32 (operador -> MINUS .)
    TRUE            reduce using rule 32 (operador -> MINUS .)
    FALSE           reduce using rule 32 (operador -> MINUS .)
    LPAREN          reduce using rule 32 (operador -> MINUS .)


state 78

    (33) operador -> EQUAL .

    NUMBER          reduce using rule 33 (operador -> EQUAL .)
    NOME            reduce using rule 33 (operador -> EQUAL .)
    CHARACTER       reduce using rule 33 (operador -> EQUAL .)
    TRUE            reduce using rule 33 (operador -> EQUAL .)
    FALSE           reduce using rule 33 (operador -> EQUAL .)
    LPAREN          reduce using rule 33 (operador -> EQUAL .)


state 79

    (34) operador -> NEQUAL .

    NUMBER          reduce using rule 34 (operador -> NEQUAL .)
    NOME            reduce using rule 34 (operador -> NEQUAL .)
    CHARACTER       reduce using rule 34 (operador -> NEQUAL .)
    TRUE            reduce using rule 34 (operador -> NEQUAL .)
    FALSE           reduce using rule 34 (operador -> NEQUAL .)
    LPAREN          reduce using rule 34 (operador -> NEQUAL .)


state 80

    (35) operador -> GT .

    NUMBER          reduce using rule 35 (operador -> GT .)
    NOME            reduce using rule 35 (operador -> GT .)
    CHARACTER       reduce using rule 35 (operador -> GT .)
    TRUE            reduce using rule 35 (operador -> GT .)
    FALSE           reduce using rule 35 (operador -> GT .)
    LPAREN          reduce using rule 35 (operador -> GT .)


state 81

    (36) operador -> LT .

    NUMBER          reduce using rule 36 (operador -> LT .)
    NOME            reduce using rule 36 (operador -> LT .)
    CHARACTER       reduce using rule 36 (operador -> LT .)
    TRUE            reduce using rule 36 (operador -> LT .)
    FALSE           reduce using rule 36 (operador -> LT .)
    LPAREN          reduce using rule 36 (operador -> LT .)


state 82

    (37) operador -> GTE .

    NUMBER          reduce using rule 37 (operador -> GTE .)
    NOME            reduce using rule 37 (operador -> GTE .)
    CHARACTER       reduce using rule 37 (operador -> GTE .)
    TRUE            reduce using rule 37 (operador -> GTE .)
    FALSE           reduce using rule 37 (operador -> GTE .)
    LPAREN          reduce using rule 37 (operador -> GTE .)


state 83

    (38) operador -> LTE .

    NUMBER          reduce using rule 38 (operador -> LTE .)
    NOME            reduce using rule 38 (operador -> LTE .)
    CHARACTER       reduce using rule 38 (operador -> LTE .)
    TRUE            reduce using rule 38 (operador -> LTE .)
    FALSE           reduce using rule 38 (operador -> LTE .)
    LPAREN          reduce using rule 38 (operador -> LTE .)


state 84

    (39) operador -> AND .

    NUMBER          reduce using rule 39 (operador -> AND .)
    NOME            reduce using rule 39 (operador -> AND .)
    CHARACTER       reduce using rule 39 (operador -> AND .)
    TRUE            reduce using rule 39 (operador -> AND .)
    FALSE           reduce using rule 39 (operador -> AND .)
    LPAREN          reduce using rule 39 (operador -> AND .)


state 85

    (40) operador -> OR .

    NUMBER          reduce using rule 40 (operador -> OR .)
    NOME            reduce using rule 40 (operador -> OR .)
    CHARACTER       reduce using rule 40 (operador -> OR .)
    TRUE            reduce using rule 40 (operador -> OR .)
    FALSE           reduce using rule 40 (operador -> OR .)
    LPAREN          reduce using rule 40 (operador -> OR .)


state 86

    (22) parentheses -> LPAREN valor . RPAREN
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 98
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 87

    (80) printf_statement -> PRINTF LPAREN valor . RPAREN SEMICOLON
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          shift and go to state 99
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 88

    (79) scanf_statement -> SCANF LPAREN NOME . RPAREN SEMICOLON

    RPAREN          shift and go to state 100


state 89

    (53) declaration_list -> NOME ASSIGN valor .
    (54) declaration_list -> NOME ASSIGN valor . COMMA declaration_list
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 53 (declaration_list -> NOME ASSIGN valor .)
    COMMA           shift and go to state 101
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 90

    (56) if_statement -> IF LPAREN valor RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 102

state 91

    (57) while_statement -> WHILE LPAREN valor RPAREN . bloco
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 103

state 92

    (58) for_statement -> FOR LPAREN for_init SEMICOLON . for_condition SEMICOLON for_update RPAREN comando
    (69) for_condition -> . assignment
    (70) for_condition -> . valor
    (71) for_condition -> . valor for_comma
    (72) for_condition -> . assignment for_comma
    (73) for_condition -> . empty
    (50) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (84) empty -> .
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 70
    NUMBER          shift and go to state 48
    CHARACTER       shift and go to state 50
    SEMICOLON       reduce using rule 84 (empty -> .)
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    for_condition                  shift and go to state 104
    assignment                     shift and go to state 105
    valor                          shift and go to state 106
    empty                          shift and go to state 107
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 93

    (63) for_init -> assignment for_comma .

    SEMICOLON       reduce using rule 63 (for_init -> assignment for_comma .)


state 94

    (66) for_comma -> COMMA . assignment
    (67) for_comma -> COMMA . valor SEMICOLON
    (68) for_comma -> COMMA . assignment for_comma
    (50) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 70
    NUMBER          shift and go to state 48
    CHARACTER       shift and go to state 50
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    assignment                     shift and go to state 108
    valor                          shift and go to state 109
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 95

    (65) for_init -> declaration for_comma .

    SEMICOLON       reduce using rule 65 (for_init -> declaration for_comma .)


state 96

    (64) for_init -> valor for_comma .

    SEMICOLON       reduce using rule 64 (for_init -> valor for_comma .)


state 97

    (49) operation -> valor operador valor .
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 49 (operation -> valor operador valor .)
    NOME            reduce using rule 49 (operation -> valor operador valor .)
    IF              reduce using rule 49 (operation -> valor operador valor .)
    WHILE           reduce using rule 49 (operation -> valor operador valor .)
    FOR             reduce using rule 49 (operation -> valor operador valor .)
    LBRACE          reduce using rule 49 (operation -> valor operador valor .)
    BREAK           reduce using rule 49 (operation -> valor operador valor .)
    CONTINUE        reduce using rule 49 (operation -> valor operador valor .)
    RETURN          reduce using rule 49 (operation -> valor operador valor .)
    PRINTF          reduce using rule 49 (operation -> valor operador valor .)
    SCANF           reduce using rule 49 (operation -> valor operador valor .)
    INT             reduce using rule 49 (operation -> valor operador valor .)
    FLOAT           reduce using rule 49 (operation -> valor operador valor .)
    CHAR            reduce using rule 49 (operation -> valor operador valor .)
    VOID            reduce using rule 49 (operation -> valor operador valor .)
    BOOL            reduce using rule 49 (operation -> valor operador valor .)
    RBRACE          reduce using rule 49 (operation -> valor operador valor .)
    COMMA           reduce using rule 49 (operation -> valor operador valor .)
    RPAREN          reduce using rule 49 (operation -> valor operador valor .)
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! MULTIPLY        [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! DIV             [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! MOD             [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! PLUS            [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! MINUS           [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! EQUAL           [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! NEQUAL          [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! GT              [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! LT              [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! GTE             [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! LTE             [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! AND             [ reduce using rule 49 (operation -> valor operador valor .) ]
  ! OR              [ reduce using rule 49 (operation -> valor operador valor .) ]

    operador                       shift and go to state 72

state 98

    (22) parentheses -> LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MULTIPLY        reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    DIV             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MOD             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    PLUS            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    MINUS           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    EQUAL           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    NEQUAL          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    GT              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    LT              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    GTE             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    LTE             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    AND             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    OR              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    NOME            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    IF              reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    WHILE           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    FOR             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    LBRACE          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    BREAK           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    CONTINUE        reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    RETURN          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    PRINTF          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    SCANF           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    INT             reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    FLOAT           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    CHAR            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    VOID            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    BOOL            reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    RBRACE          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    COMMA           reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)
    RPAREN          reduce using rule 22 (parentheses -> LPAREN valor RPAREN .)


state 99

    (80) printf_statement -> PRINTF LPAREN valor RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 110


state 100

    (79) scanf_statement -> SCANF LPAREN NOME RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 111


state 101

    (54) declaration_list -> NOME ASSIGN valor COMMA . declaration_list
    (51) declaration_list -> . NOME
    (52) declaration_list -> . NOME declaration_list
    (53) declaration_list -> . NOME ASSIGN valor
    (54) declaration_list -> . NOME ASSIGN valor COMMA declaration_list

    NOME            shift and go to state 40

    declaration_list               shift and go to state 112

state 102

    (56) if_statement -> IF LPAREN valor RPAREN bloco .

    NOME            reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    IF              reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    WHILE           reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    FOR             reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    LBRACE          reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    BREAK           reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    CONTINUE        reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    RETURN          reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    PRINTF          reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    SCANF           reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    INT             reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    FLOAT           reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    CHAR            reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    VOID            reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    BOOL            reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)
    RBRACE          reduce using rule 56 (if_statement -> IF LPAREN valor RPAREN bloco .)


state 103

    (57) while_statement -> WHILE LPAREN valor RPAREN bloco .

    NOME            reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    IF              reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    WHILE           reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    FOR             reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    LBRACE          reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    BREAK           reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    CONTINUE        reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    RETURN          reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    PRINTF          reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    SCANF           reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    INT             reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    FLOAT           reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    CHAR            reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    VOID            reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    BOOL            reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)
    RBRACE          reduce using rule 57 (while_statement -> WHILE LPAREN valor RPAREN bloco .)


state 104

    (58) for_statement -> FOR LPAREN for_init SEMICOLON for_condition . SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 113


state 105

    (69) for_condition -> assignment .
    (72) for_condition -> assignment . for_comma
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 69 (for_condition -> assignment .)
    COMMA           shift and go to state 94

    for_comma                      shift and go to state 114

state 106

    (70) for_condition -> valor .
    (71) for_condition -> valor . for_comma
    (49) operation -> valor . operador valor
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       reduce using rule 70 (for_condition -> valor .)
    COMMA           shift and go to state 94
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    for_comma                      shift and go to state 115
    operador                       shift and go to state 72

state 107

    (73) for_condition -> empty .

    SEMICOLON       reduce using rule 73 (for_condition -> empty .)


state 108

    (66) for_comma -> COMMA assignment .
    (68) for_comma -> COMMA assignment . for_comma
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma

    SEMICOLON       reduce using rule 66 (for_comma -> COMMA assignment .)
    RPAREN          reduce using rule 66 (for_comma -> COMMA assignment .)
    COMMA           shift and go to state 94

    for_comma                      shift and go to state 116

state 109

    (67) for_comma -> COMMA valor . SEMICOLON
    (49) operation -> valor . operador valor
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    SEMICOLON       shift and go to state 117
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    operador                       shift and go to state 72

state 110

    (80) printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .

    NOME            reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    IF              reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    WHILE           reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    FOR             reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    LBRACE          reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    BREAK           reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    RETURN          reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    PRINTF          reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    SCANF           reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    INT             reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    FLOAT           reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    CHAR            reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    VOID            reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    BOOL            reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)
    RBRACE          reduce using rule 80 (printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON .)


state 111

    (79) scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .

    NOME            reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    IF              reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    WHILE           reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    FOR             reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    LBRACE          reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    BREAK           reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    RETURN          reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    PRINTF          reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    SCANF           reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    INT             reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    FLOAT           reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    CHAR            reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    VOID            reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    BOOL            reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)
    RBRACE          reduce using rule 79 (scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON .)


state 112

    (54) declaration_list -> NOME ASSIGN valor COMMA declaration_list .

    SEMICOLON       reduce using rule 54 (declaration_list -> NOME ASSIGN valor COMMA declaration_list .)


state 113

    (58) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON . for_update RPAREN comando
    (74) for_update -> . assignment
    (75) for_update -> . valor
    (76) for_update -> . valor for_comma
    (77) for_update -> . assignment for_comma
    (78) for_update -> . empty
    (50) assignment -> . NOME ASSIGN valor
    (43) valor -> . NUMBER
    (44) valor -> . NOME
    (45) valor -> . CHARACTER
    (46) valor -> . boolean
    (47) valor -> . operation
    (48) valor -> . parentheses
    (84) empty -> .
    (41) boolean -> . TRUE
    (42) boolean -> . FALSE
    (49) operation -> . valor operador valor
    (22) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 70
    NUMBER          shift and go to state 48
    CHARACTER       shift and go to state 50
    RPAREN          reduce using rule 84 (empty -> .)
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    LPAREN          shift and go to state 56

    for_update                     shift and go to state 118
    assignment                     shift and go to state 119
    valor                          shift and go to state 120
    empty                          shift and go to state 121
    boolean                        shift and go to state 51
    operation                      shift and go to state 52
    parentheses                    shift and go to state 53

state 114

    (72) for_condition -> assignment for_comma .

    SEMICOLON       reduce using rule 72 (for_condition -> assignment for_comma .)


state 115

    (71) for_condition -> valor for_comma .

    SEMICOLON       reduce using rule 71 (for_condition -> valor for_comma .)


state 116

    (68) for_comma -> COMMA assignment for_comma .

    SEMICOLON       reduce using rule 68 (for_comma -> COMMA assignment for_comma .)
    RPAREN          reduce using rule 68 (for_comma -> COMMA assignment for_comma .)


state 117

    (67) for_comma -> COMMA valor SEMICOLON .

    SEMICOLON       reduce using rule 67 (for_comma -> COMMA valor SEMICOLON .)
    RPAREN          reduce using rule 67 (for_comma -> COMMA valor SEMICOLON .)


state 118

    (58) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update . RPAREN comando

    RPAREN          shift and go to state 122


state 119

    (74) for_update -> assignment .
    (77) for_update -> assignment . for_comma
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma

    RPAREN          reduce using rule 74 (for_update -> assignment .)
    COMMA           shift and go to state 94

    for_comma                      shift and go to state 123

state 120

    (75) for_update -> valor .
    (76) for_update -> valor . for_comma
    (49) operation -> valor . operador valor
    (66) for_comma -> . COMMA assignment
    (67) for_comma -> . COMMA valor SEMICOLON
    (68) for_comma -> . COMMA assignment for_comma
    (28) operador -> . MULTIPLY
    (29) operador -> . DIV
    (30) operador -> . MOD
    (31) operador -> . PLUS
    (32) operador -> . MINUS
    (33) operador -> . EQUAL
    (34) operador -> . NEQUAL
    (35) operador -> . GT
    (36) operador -> . LT
    (37) operador -> . GTE
    (38) operador -> . LTE
    (39) operador -> . AND
    (40) operador -> . OR

    RPAREN          reduce using rule 75 (for_update -> valor .)
    COMMA           shift and go to state 94
    MULTIPLY        shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    EQUAL           shift and go to state 78
    NEQUAL          shift and go to state 79
    GT              shift and go to state 80
    LT              shift and go to state 81
    GTE             shift and go to state 82
    LTE             shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    for_comma                      shift and go to state 124
    operador                       shift and go to state 72

state 121

    (78) for_update -> empty .

    RPAREN          reduce using rule 78 (for_update -> empty .)


state 122

    (58) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN . comando
    (7) comando -> . declaration
    (8) comando -> . assignment
    (9) comando -> . if_statement
    (10) comando -> . while_statement
    (11) comando -> . for_statement
    (12) comando -> . bloco
    (13) comando -> . break_statement
    (14) comando -> . continue_statement
    (15) comando -> . return_statement
    (16) comando -> . printf_statement
    (17) comando -> . scanf_statement
    (55) declaration -> . type declaration_list SEMICOLON
    (50) assignment -> . NOME ASSIGN valor
    (56) if_statement -> . IF LPAREN valor RPAREN bloco
    (57) while_statement -> . WHILE LPAREN valor RPAREN bloco
    (58) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (20) bloco -> . LBRACE comandos RBRACE
    (21) bloco -> . LBRACE RBRACE
    (81) break_statement -> . BREAK SEMICOLON
    (82) continue_statement -> . CONTINUE SEMICOLON
    (83) return_statement -> . RETURN valor SEMICOLON
    (80) printf_statement -> . PRINTF LPAREN valor RPAREN SEMICOLON
    (79) scanf_statement -> . SCANF LPAREN NOME RPAREN SEMICOLON
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . CHAR
    (26) type -> . VOID
    (27) type -> . BOOL

    NOME            shift and go to state 23
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LBRACE          shift and go to state 7
    BREAK           shift and go to state 27
    CONTINUE        shift and go to state 28
    RETURN          shift and go to state 29
    PRINTF          shift and go to state 30
    SCANF           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    BOOL            shift and go to state 36

    comando                        shift and go to state 125
    declaration                    shift and go to state 11
    assignment                     shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    for_statement                  shift and go to state 15
    bloco                          shift and go to state 16
    break_statement                shift and go to state 17
    continue_statement             shift and go to state 18
    return_statement               shift and go to state 19
    printf_statement               shift and go to state 20
    scanf_statement                shift and go to state 21
    type                           shift and go to state 22

state 123

    (77) for_update -> assignment for_comma .

    RPAREN          reduce using rule 77 (for_update -> assignment for_comma .)


state 124

    (76) for_update -> valor for_comma .

    RPAREN          reduce using rule 76 (for_update -> valor for_comma .)


state 125

    (58) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .

    NOME            reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    IF              reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    WHILE           reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    FOR             reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    LBRACE          reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    BREAK           reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    CONTINUE        reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    RETURN          reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    PRINTF          reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    SCANF           reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    INT             reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    FLOAT           reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    CHAR            reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    VOID            reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    BOOL            reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)
    RBRACE          reduce using rule 58 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MULTIPLY in state 97 resolved as shift
WARNING: shift/reduce conflict for DIV in state 97 resolved as shift
WARNING: shift/reduce conflict for MOD in state 97 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 97 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 97 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for GT in state 97 resolved as shift
WARNING: shift/reduce conflict for LT in state 97 resolved as shift
WARNING: shift/reduce conflict for GTE in state 97 resolved as shift
WARNING: shift/reduce conflict for LTE in state 97 resolved as shift
WARNING: shift/reduce conflict for AND in state 97 resolved as shift
WARNING: shift/reduce conflict for OR in state 97 resolved as shift
