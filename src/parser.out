Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT
    ELSE
    LBRACKET
    RBRACKET
    SQUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> INT MAIN LPAREN RPAREN bloco
Rule 2     sinal -> NOT PLUS
Rule 3     sinal -> NOT MINUS
Rule 4     sinal -> NOT
Rule 5     sinal -> PLUS
Rule 6     sinal -> MINUS
Rule 7     comando -> declaration
Rule 8     comando -> if_statement
Rule 9     comando -> while_statement
Rule 10    comando -> for_statement
Rule 11    comando -> break_statement
Rule 12    comando -> continue_statement
Rule 13    comando -> return_statement
Rule 14    type -> INT
Rule 15    type -> FLOAT
Rule 16    type -> CHAR
Rule 17    type -> VOID
Rule 18    type -> BOOL
Rule 19    operador -> MULTIPLY
Rule 20    operador -> DIV
Rule 21    operador -> MOD
Rule 22    operador -> PLUS
Rule 23    operador -> MINUS
Rule 24    operador -> EQUAL
Rule 25    operador -> NEQUAL
Rule 26    operador -> GT
Rule 27    operador -> LT
Rule 28    operador -> GTE
Rule 29    operador -> LTE
Rule 30    operador -> AND
Rule 31    operador -> OR
Rule 32    boolean -> TRUE
Rule 33    boolean -> FALSE
Rule 34    valor -> NUMBER
Rule 35    valor -> CHARACTER
Rule 36    valor -> boolean
Rule 37    valor -> operation
Rule 38    valor -> parentheses
Rule 39    operation -> valor operador valor
Rule 40    assignment -> NOME valor
Rule 41    declare -> type NOME valor
Rule 42    declaration_list -> declaration_list COMMA declaration
Rule 43    declaration_list -> declaration
Rule 44    declaration -> type NOME ASSIGN valor SEMICOLON
Rule 45    declaration -> type NOME SEMICOLON
Rule 46    parentheses -> LPAREN valor RPAREN
Rule 47    bloco -> LBRACE comando RBRACE
Rule 48    bloco -> LBRACE RBRACE
Rule 49    if_statement -> IF LPAREN valor RPAREN LBRACE bloco RBRACE
Rule 50    while_statement -> WHILE LPAREN valor RPAREN LBRACE bloco RBRACE
Rule 51    for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
Rule 52    for_init -> assignment
Rule 53    for_init -> declaration
Rule 54    for_init -> valor
Rule 55    for_init -> empty
Rule 56    for_init -> valor for_init_comma
Rule 57    for_init -> declaration for_init_comma
Rule 58    for_init_comma -> COMMA assignment
Rule 59    for_init_comma -> COMMA assignment for_init_comma
Rule 60    for_condition -> assignment
Rule 61    for_condition -> valor
Rule 62    for_condition -> empty
Rule 63    for_update -> assignment
Rule 64    for_update -> valor
Rule 65    for_update -> empty
Rule 66    scanf_statement -> SCANF LPAREN NOME RPAREN SEMICOLON
Rule 67    printf_statement -> PRINTF LPAREN valor RPAREN SEMICOLON
Rule 68    break_statement -> BREAK SEMICOLON
Rule 69    continue_statement -> CONTINUE SEMICOLON
Rule 70    return_statement -> RETURN valor SEMICOLON
Rule 71    empty -> <empty>

Terminals, with rules where they appear

AND                  : 30
ASSIGN               : 44
BOOL                 : 18
BREAK                : 68
CHAR                 : 16
CHARACTER            : 35
COMMA                : 42 58 59
CONTINUE             : 69
DIV                  : 20
DOT                  : 
ELSE                 : 
EQUAL                : 24
FALSE                : 33
FLOAT                : 15
FOR                  : 51
GT                   : 26
GTE                  : 28
IF                   : 49
INT                  : 1 14
LBRACE               : 47 48 49 50
LBRACKET             : 
LPAREN               : 1 46 49 50 51 66 67
LT                   : 27
LTE                  : 29
MAIN                 : 1
MINUS                : 3 6 23
MOD                  : 21
MULTIPLY             : 19
NEQUAL               : 25
NOME                 : 40 41 44 45 66
NOT                  : 2 3 4
NUMBER               : 34
OR                   : 31
PLUS                 : 2 5 22
PRINTF               : 67
RBRACE               : 47 48 49 50
RBRACKET             : 
RETURN               : 70
RPAREN               : 1 46 49 50 51 66 67
SCANF                : 66
SEMICOLON            : 44 45 51 51 66 67 68 69 70
SQUOTE               : 
TRUE                 : 32
VOID                 : 17
WHILE                : 50
error                : 

Nonterminals, with rules where they appear

assignment           : 52 58 59 60 63
bloco                : 1 49 50
boolean              : 36
break_statement      : 11
comando              : 47 51
continue_statement   : 12
declaration          : 7 42 43 53 57
declaration_list     : 42
declare              : 
empty                : 55 62 65
for_condition        : 51
for_init             : 51
for_init_comma       : 56 57 59
for_statement        : 10
for_update           : 51
if_statement         : 8
operador             : 39
operation            : 37
parentheses          : 38
printf_statement     : 
program              : 0
return_statement     : 13
scanf_statement      : 
sinal                : 
type                 : 41 44 45
valor                : 39 39 40 41 44 46 49 50 54 56 61 64 67 70
while_statement      : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INT MAIN LPAREN RPAREN bloco

    INT             shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> INT . MAIN LPAREN RPAREN bloco

    MAIN            shift and go to state 3


state 3

    (1) program -> INT MAIN . LPAREN RPAREN bloco

    LPAREN          shift and go to state 4


state 4

    (1) program -> INT MAIN LPAREN . RPAREN bloco

    RPAREN          shift and go to state 5


state 5

    (1) program -> INT MAIN LPAREN RPAREN . bloco
    (47) bloco -> . LBRACE comando RBRACE
    (48) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 6

state 6

    (1) program -> INT MAIN LPAREN RPAREN bloco .

    $end            reduce using rule 1 (program -> INT MAIN LPAREN RPAREN bloco .)


state 7

    (47) bloco -> LBRACE . comando RBRACE
    (48) bloco -> LBRACE . RBRACE
    (7) comando -> . declaration
    (8) comando -> . if_statement
    (9) comando -> . while_statement
    (10) comando -> . for_statement
    (11) comando -> . break_statement
    (12) comando -> . continue_statement
    (13) comando -> . return_statement
    (44) declaration -> . type NOME ASSIGN valor SEMICOLON
    (45) declaration -> . type NOME SEMICOLON
    (49) if_statement -> . IF LPAREN valor RPAREN LBRACE bloco RBRACE
    (50) while_statement -> . WHILE LPAREN valor RPAREN LBRACE bloco RBRACE
    (51) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (68) break_statement -> . BREAK SEMICOLON
    (69) continue_statement -> . CONTINUE SEMICOLON
    (70) return_statement -> . RETURN valor SEMICOLON
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . CHAR
    (17) type -> . VOID
    (18) type -> . BOOL

    RBRACE          shift and go to state 9
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 23
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    CHAR            shift and go to state 26
    VOID            shift and go to state 27
    BOOL            shift and go to state 28

    comando                        shift and go to state 8
    declaration                    shift and go to state 10
    if_statement                   shift and go to state 11
    while_statement                shift and go to state 12
    for_statement                  shift and go to state 13
    break_statement                shift and go to state 14
    continue_statement             shift and go to state 15
    return_statement               shift and go to state 16
    type                           shift and go to state 17

state 8

    (47) bloco -> LBRACE comando . RBRACE

    RBRACE          shift and go to state 29


state 9

    (48) bloco -> LBRACE RBRACE .

    $end            reduce using rule 48 (bloco -> LBRACE RBRACE .)
    RBRACE          reduce using rule 48 (bloco -> LBRACE RBRACE .)


state 10

    (7) comando -> declaration .

    RBRACE          reduce using rule 7 (comando -> declaration .)


state 11

    (8) comando -> if_statement .

    RBRACE          reduce using rule 8 (comando -> if_statement .)


state 12

    (9) comando -> while_statement .

    RBRACE          reduce using rule 9 (comando -> while_statement .)


state 13

    (10) comando -> for_statement .

    RBRACE          reduce using rule 10 (comando -> for_statement .)


state 14

    (11) comando -> break_statement .

    RBRACE          reduce using rule 11 (comando -> break_statement .)


state 15

    (12) comando -> continue_statement .

    RBRACE          reduce using rule 12 (comando -> continue_statement .)


state 16

    (13) comando -> return_statement .

    RBRACE          reduce using rule 13 (comando -> return_statement .)


state 17

    (44) declaration -> type . NOME ASSIGN valor SEMICOLON
    (45) declaration -> type . NOME SEMICOLON

    NOME            shift and go to state 30


state 18

    (49) if_statement -> IF . LPAREN valor RPAREN LBRACE bloco RBRACE

    LPAREN          shift and go to state 31


state 19

    (50) while_statement -> WHILE . LPAREN valor RPAREN LBRACE bloco RBRACE

    LPAREN          shift and go to state 32


state 20

    (51) for_statement -> FOR . LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    LPAREN          shift and go to state 33


state 21

    (68) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 34


state 22

    (69) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 35


state 23

    (70) return_statement -> RETURN . valor SEMICOLON
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 36
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 24

    (14) type -> INT .

    NOME            reduce using rule 14 (type -> INT .)


state 25

    (15) type -> FLOAT .

    NOME            reduce using rule 15 (type -> FLOAT .)


state 26

    (16) type -> CHAR .

    NOME            reduce using rule 16 (type -> CHAR .)


state 27

    (17) type -> VOID .

    NOME            reduce using rule 17 (type -> VOID .)


state 28

    (18) type -> BOOL .

    NOME            reduce using rule 18 (type -> BOOL .)


state 29

    (47) bloco -> LBRACE comando RBRACE .

    $end            reduce using rule 47 (bloco -> LBRACE comando RBRACE .)
    RBRACE          reduce using rule 47 (bloco -> LBRACE comando RBRACE .)


state 30

    (44) declaration -> type NOME . ASSIGN valor SEMICOLON
    (45) declaration -> type NOME . SEMICOLON

    ASSIGN          shift and go to state 45
    SEMICOLON       shift and go to state 46


state 31

    (49) if_statement -> IF LPAREN . valor RPAREN LBRACE bloco RBRACE
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 47
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 32

    (50) while_statement -> WHILE LPAREN . valor RPAREN LBRACE bloco RBRACE
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 48
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 33

    (51) for_statement -> FOR LPAREN . for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (52) for_init -> . assignment
    (53) for_init -> . declaration
    (54) for_init -> . valor
    (55) for_init -> . empty
    (56) for_init -> . valor for_init_comma
    (57) for_init -> . declaration for_init_comma
    (40) assignment -> . NOME valor
    (44) declaration -> . type NOME ASSIGN valor SEMICOLON
    (45) declaration -> . type NOME SEMICOLON
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (71) empty -> .
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . CHAR
    (17) type -> . VOID
    (18) type -> . BOOL
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 54
    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    SEMICOLON       reduce using rule 71 (empty -> .)
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    CHAR            shift and go to state 26
    VOID            shift and go to state 27
    BOOL            shift and go to state 28
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    for_init                       shift and go to state 49
    assignment                     shift and go to state 50
    declaration                    shift and go to state 51
    valor                          shift and go to state 52
    empty                          shift and go to state 53
    type                           shift and go to state 17
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 34

    (68) break_statement -> BREAK SEMICOLON .

    RBRACE          reduce using rule 68 (break_statement -> BREAK SEMICOLON .)


state 35

    (69) continue_statement -> CONTINUE SEMICOLON .

    RBRACE          reduce using rule 69 (continue_statement -> CONTINUE SEMICOLON .)


state 36

    (70) return_statement -> RETURN valor . SEMICOLON
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    SEMICOLON       shift and go to state 55
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 37

    (34) valor -> NUMBER .

    SEMICOLON       reduce using rule 34 (valor -> NUMBER .)
    MULTIPLY        reduce using rule 34 (valor -> NUMBER .)
    DIV             reduce using rule 34 (valor -> NUMBER .)
    MOD             reduce using rule 34 (valor -> NUMBER .)
    PLUS            reduce using rule 34 (valor -> NUMBER .)
    MINUS           reduce using rule 34 (valor -> NUMBER .)
    EQUAL           reduce using rule 34 (valor -> NUMBER .)
    NEQUAL          reduce using rule 34 (valor -> NUMBER .)
    GT              reduce using rule 34 (valor -> NUMBER .)
    LT              reduce using rule 34 (valor -> NUMBER .)
    GTE             reduce using rule 34 (valor -> NUMBER .)
    LTE             reduce using rule 34 (valor -> NUMBER .)
    AND             reduce using rule 34 (valor -> NUMBER .)
    OR              reduce using rule 34 (valor -> NUMBER .)
    RPAREN          reduce using rule 34 (valor -> NUMBER .)
    COMMA           reduce using rule 34 (valor -> NUMBER .)


state 38

    (35) valor -> CHARACTER .

    SEMICOLON       reduce using rule 35 (valor -> CHARACTER .)
    MULTIPLY        reduce using rule 35 (valor -> CHARACTER .)
    DIV             reduce using rule 35 (valor -> CHARACTER .)
    MOD             reduce using rule 35 (valor -> CHARACTER .)
    PLUS            reduce using rule 35 (valor -> CHARACTER .)
    MINUS           reduce using rule 35 (valor -> CHARACTER .)
    EQUAL           reduce using rule 35 (valor -> CHARACTER .)
    NEQUAL          reduce using rule 35 (valor -> CHARACTER .)
    GT              reduce using rule 35 (valor -> CHARACTER .)
    LT              reduce using rule 35 (valor -> CHARACTER .)
    GTE             reduce using rule 35 (valor -> CHARACTER .)
    LTE             reduce using rule 35 (valor -> CHARACTER .)
    AND             reduce using rule 35 (valor -> CHARACTER .)
    OR              reduce using rule 35 (valor -> CHARACTER .)
    RPAREN          reduce using rule 35 (valor -> CHARACTER .)
    COMMA           reduce using rule 35 (valor -> CHARACTER .)


state 39

    (36) valor -> boolean .

    SEMICOLON       reduce using rule 36 (valor -> boolean .)
    MULTIPLY        reduce using rule 36 (valor -> boolean .)
    DIV             reduce using rule 36 (valor -> boolean .)
    MOD             reduce using rule 36 (valor -> boolean .)
    PLUS            reduce using rule 36 (valor -> boolean .)
    MINUS           reduce using rule 36 (valor -> boolean .)
    EQUAL           reduce using rule 36 (valor -> boolean .)
    NEQUAL          reduce using rule 36 (valor -> boolean .)
    GT              reduce using rule 36 (valor -> boolean .)
    LT              reduce using rule 36 (valor -> boolean .)
    GTE             reduce using rule 36 (valor -> boolean .)
    LTE             reduce using rule 36 (valor -> boolean .)
    AND             reduce using rule 36 (valor -> boolean .)
    OR              reduce using rule 36 (valor -> boolean .)
    RPAREN          reduce using rule 36 (valor -> boolean .)
    COMMA           reduce using rule 36 (valor -> boolean .)


state 40

    (37) valor -> operation .

    SEMICOLON       reduce using rule 37 (valor -> operation .)
    MULTIPLY        reduce using rule 37 (valor -> operation .)
    DIV             reduce using rule 37 (valor -> operation .)
    MOD             reduce using rule 37 (valor -> operation .)
    PLUS            reduce using rule 37 (valor -> operation .)
    MINUS           reduce using rule 37 (valor -> operation .)
    EQUAL           reduce using rule 37 (valor -> operation .)
    NEQUAL          reduce using rule 37 (valor -> operation .)
    GT              reduce using rule 37 (valor -> operation .)
    LT              reduce using rule 37 (valor -> operation .)
    GTE             reduce using rule 37 (valor -> operation .)
    LTE             reduce using rule 37 (valor -> operation .)
    AND             reduce using rule 37 (valor -> operation .)
    OR              reduce using rule 37 (valor -> operation .)
    RPAREN          reduce using rule 37 (valor -> operation .)
    COMMA           reduce using rule 37 (valor -> operation .)


state 41

    (38) valor -> parentheses .

    SEMICOLON       reduce using rule 38 (valor -> parentheses .)
    MULTIPLY        reduce using rule 38 (valor -> parentheses .)
    DIV             reduce using rule 38 (valor -> parentheses .)
    MOD             reduce using rule 38 (valor -> parentheses .)
    PLUS            reduce using rule 38 (valor -> parentheses .)
    MINUS           reduce using rule 38 (valor -> parentheses .)
    EQUAL           reduce using rule 38 (valor -> parentheses .)
    NEQUAL          reduce using rule 38 (valor -> parentheses .)
    GT              reduce using rule 38 (valor -> parentheses .)
    LT              reduce using rule 38 (valor -> parentheses .)
    GTE             reduce using rule 38 (valor -> parentheses .)
    LTE             reduce using rule 38 (valor -> parentheses .)
    AND             reduce using rule 38 (valor -> parentheses .)
    OR              reduce using rule 38 (valor -> parentheses .)
    RPAREN          reduce using rule 38 (valor -> parentheses .)
    COMMA           reduce using rule 38 (valor -> parentheses .)


state 42

    (32) boolean -> TRUE .

    SEMICOLON       reduce using rule 32 (boolean -> TRUE .)
    MULTIPLY        reduce using rule 32 (boolean -> TRUE .)
    DIV             reduce using rule 32 (boolean -> TRUE .)
    MOD             reduce using rule 32 (boolean -> TRUE .)
    PLUS            reduce using rule 32 (boolean -> TRUE .)
    MINUS           reduce using rule 32 (boolean -> TRUE .)
    EQUAL           reduce using rule 32 (boolean -> TRUE .)
    NEQUAL          reduce using rule 32 (boolean -> TRUE .)
    GT              reduce using rule 32 (boolean -> TRUE .)
    LT              reduce using rule 32 (boolean -> TRUE .)
    GTE             reduce using rule 32 (boolean -> TRUE .)
    LTE             reduce using rule 32 (boolean -> TRUE .)
    AND             reduce using rule 32 (boolean -> TRUE .)
    OR              reduce using rule 32 (boolean -> TRUE .)
    RPAREN          reduce using rule 32 (boolean -> TRUE .)
    COMMA           reduce using rule 32 (boolean -> TRUE .)


state 43

    (33) boolean -> FALSE .

    SEMICOLON       reduce using rule 33 (boolean -> FALSE .)
    MULTIPLY        reduce using rule 33 (boolean -> FALSE .)
    DIV             reduce using rule 33 (boolean -> FALSE .)
    MOD             reduce using rule 33 (boolean -> FALSE .)
    PLUS            reduce using rule 33 (boolean -> FALSE .)
    MINUS           reduce using rule 33 (boolean -> FALSE .)
    EQUAL           reduce using rule 33 (boolean -> FALSE .)
    NEQUAL          reduce using rule 33 (boolean -> FALSE .)
    GT              reduce using rule 33 (boolean -> FALSE .)
    LT              reduce using rule 33 (boolean -> FALSE .)
    GTE             reduce using rule 33 (boolean -> FALSE .)
    LTE             reduce using rule 33 (boolean -> FALSE .)
    AND             reduce using rule 33 (boolean -> FALSE .)
    OR              reduce using rule 33 (boolean -> FALSE .)
    RPAREN          reduce using rule 33 (boolean -> FALSE .)
    COMMA           reduce using rule 33 (boolean -> FALSE .)


state 44

    (46) parentheses -> LPAREN . valor RPAREN
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 70
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 45

    (44) declaration -> type NOME ASSIGN . valor SEMICOLON
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 71
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 46

    (45) declaration -> type NOME SEMICOLON .

    RBRACE          reduce using rule 45 (declaration -> type NOME SEMICOLON .)
    COMMA           reduce using rule 45 (declaration -> type NOME SEMICOLON .)
    SEMICOLON       reduce using rule 45 (declaration -> type NOME SEMICOLON .)


state 47

    (49) if_statement -> IF LPAREN valor . RPAREN LBRACE bloco RBRACE
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    RPAREN          shift and go to state 72
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 48

    (50) while_statement -> WHILE LPAREN valor . RPAREN LBRACE bloco RBRACE
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    RPAREN          shift and go to state 73
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 49

    (51) for_statement -> FOR LPAREN for_init . SEMICOLON for_condition SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 74


state 50

    (52) for_init -> assignment .

    SEMICOLON       reduce using rule 52 (for_init -> assignment .)


state 51

    (53) for_init -> declaration .
    (57) for_init -> declaration . for_init_comma
    (58) for_init_comma -> . COMMA assignment
    (59) for_init_comma -> . COMMA assignment for_init_comma

    SEMICOLON       reduce using rule 53 (for_init -> declaration .)
    COMMA           shift and go to state 76

    for_init_comma                 shift and go to state 75

state 52

    (54) for_init -> valor .
    (56) for_init -> valor . for_init_comma
    (39) operation -> valor . operador valor
    (58) for_init_comma -> . COMMA assignment
    (59) for_init_comma -> . COMMA assignment for_init_comma
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    SEMICOLON       reduce using rule 54 (for_init -> valor .)
    COMMA           shift and go to state 76
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    for_init_comma                 shift and go to state 77
    operador                       shift and go to state 56

state 53

    (55) for_init -> empty .

    SEMICOLON       reduce using rule 55 (for_init -> empty .)


state 54

    (40) assignment -> NOME . valor
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 78
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 55

    (70) return_statement -> RETURN valor SEMICOLON .

    RBRACE          reduce using rule 70 (return_statement -> RETURN valor SEMICOLON .)


state 56

    (39) operation -> valor operador . valor
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    valor                          shift and go to state 79
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 57

    (19) operador -> MULTIPLY .

    NUMBER          reduce using rule 19 (operador -> MULTIPLY .)
    CHARACTER       reduce using rule 19 (operador -> MULTIPLY .)
    TRUE            reduce using rule 19 (operador -> MULTIPLY .)
    FALSE           reduce using rule 19 (operador -> MULTIPLY .)
    LPAREN          reduce using rule 19 (operador -> MULTIPLY .)


state 58

    (20) operador -> DIV .

    NUMBER          reduce using rule 20 (operador -> DIV .)
    CHARACTER       reduce using rule 20 (operador -> DIV .)
    TRUE            reduce using rule 20 (operador -> DIV .)
    FALSE           reduce using rule 20 (operador -> DIV .)
    LPAREN          reduce using rule 20 (operador -> DIV .)


state 59

    (21) operador -> MOD .

    NUMBER          reduce using rule 21 (operador -> MOD .)
    CHARACTER       reduce using rule 21 (operador -> MOD .)
    TRUE            reduce using rule 21 (operador -> MOD .)
    FALSE           reduce using rule 21 (operador -> MOD .)
    LPAREN          reduce using rule 21 (operador -> MOD .)


state 60

    (22) operador -> PLUS .

    NUMBER          reduce using rule 22 (operador -> PLUS .)
    CHARACTER       reduce using rule 22 (operador -> PLUS .)
    TRUE            reduce using rule 22 (operador -> PLUS .)
    FALSE           reduce using rule 22 (operador -> PLUS .)
    LPAREN          reduce using rule 22 (operador -> PLUS .)


state 61

    (23) operador -> MINUS .

    NUMBER          reduce using rule 23 (operador -> MINUS .)
    CHARACTER       reduce using rule 23 (operador -> MINUS .)
    TRUE            reduce using rule 23 (operador -> MINUS .)
    FALSE           reduce using rule 23 (operador -> MINUS .)
    LPAREN          reduce using rule 23 (operador -> MINUS .)


state 62

    (24) operador -> EQUAL .

    NUMBER          reduce using rule 24 (operador -> EQUAL .)
    CHARACTER       reduce using rule 24 (operador -> EQUAL .)
    TRUE            reduce using rule 24 (operador -> EQUAL .)
    FALSE           reduce using rule 24 (operador -> EQUAL .)
    LPAREN          reduce using rule 24 (operador -> EQUAL .)


state 63

    (25) operador -> NEQUAL .

    NUMBER          reduce using rule 25 (operador -> NEQUAL .)
    CHARACTER       reduce using rule 25 (operador -> NEQUAL .)
    TRUE            reduce using rule 25 (operador -> NEQUAL .)
    FALSE           reduce using rule 25 (operador -> NEQUAL .)
    LPAREN          reduce using rule 25 (operador -> NEQUAL .)


state 64

    (26) operador -> GT .

    NUMBER          reduce using rule 26 (operador -> GT .)
    CHARACTER       reduce using rule 26 (operador -> GT .)
    TRUE            reduce using rule 26 (operador -> GT .)
    FALSE           reduce using rule 26 (operador -> GT .)
    LPAREN          reduce using rule 26 (operador -> GT .)


state 65

    (27) operador -> LT .

    NUMBER          reduce using rule 27 (operador -> LT .)
    CHARACTER       reduce using rule 27 (operador -> LT .)
    TRUE            reduce using rule 27 (operador -> LT .)
    FALSE           reduce using rule 27 (operador -> LT .)
    LPAREN          reduce using rule 27 (operador -> LT .)


state 66

    (28) operador -> GTE .

    NUMBER          reduce using rule 28 (operador -> GTE .)
    CHARACTER       reduce using rule 28 (operador -> GTE .)
    TRUE            reduce using rule 28 (operador -> GTE .)
    FALSE           reduce using rule 28 (operador -> GTE .)
    LPAREN          reduce using rule 28 (operador -> GTE .)


state 67

    (29) operador -> LTE .

    NUMBER          reduce using rule 29 (operador -> LTE .)
    CHARACTER       reduce using rule 29 (operador -> LTE .)
    TRUE            reduce using rule 29 (operador -> LTE .)
    FALSE           reduce using rule 29 (operador -> LTE .)
    LPAREN          reduce using rule 29 (operador -> LTE .)


state 68

    (30) operador -> AND .

    NUMBER          reduce using rule 30 (operador -> AND .)
    CHARACTER       reduce using rule 30 (operador -> AND .)
    TRUE            reduce using rule 30 (operador -> AND .)
    FALSE           reduce using rule 30 (operador -> AND .)
    LPAREN          reduce using rule 30 (operador -> AND .)


state 69

    (31) operador -> OR .

    NUMBER          reduce using rule 31 (operador -> OR .)
    CHARACTER       reduce using rule 31 (operador -> OR .)
    TRUE            reduce using rule 31 (operador -> OR .)
    FALSE           reduce using rule 31 (operador -> OR .)
    LPAREN          reduce using rule 31 (operador -> OR .)


state 70

    (46) parentheses -> LPAREN valor . RPAREN
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    RPAREN          shift and go to state 80
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 71

    (44) declaration -> type NOME ASSIGN valor . SEMICOLON
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    SEMICOLON       shift and go to state 81
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 72

    (49) if_statement -> IF LPAREN valor RPAREN . LBRACE bloco RBRACE

    LBRACE          shift and go to state 82


state 73

    (50) while_statement -> WHILE LPAREN valor RPAREN . LBRACE bloco RBRACE

    LBRACE          shift and go to state 83


state 74

    (51) for_statement -> FOR LPAREN for_init SEMICOLON . for_condition SEMICOLON for_update RPAREN comando
    (60) for_condition -> . assignment
    (61) for_condition -> . valor
    (62) for_condition -> . empty
    (40) assignment -> . NOME valor
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (71) empty -> .
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 54
    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    SEMICOLON       reduce using rule 71 (empty -> .)
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    for_condition                  shift and go to state 84
    assignment                     shift and go to state 85
    valor                          shift and go to state 86
    empty                          shift and go to state 87
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 75

    (57) for_init -> declaration for_init_comma .

    SEMICOLON       reduce using rule 57 (for_init -> declaration for_init_comma .)


state 76

    (58) for_init_comma -> COMMA . assignment
    (59) for_init_comma -> COMMA . assignment for_init_comma
    (40) assignment -> . NOME valor

    NOME            shift and go to state 54

    assignment                     shift and go to state 88

state 77

    (56) for_init -> valor for_init_comma .

    SEMICOLON       reduce using rule 56 (for_init -> valor for_init_comma .)


state 78

    (40) assignment -> NOME valor .
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    SEMICOLON       reduce using rule 40 (assignment -> NOME valor .)
    COMMA           reduce using rule 40 (assignment -> NOME valor .)
    RPAREN          reduce using rule 40 (assignment -> NOME valor .)
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 79

    (39) operation -> valor operador valor .
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 39 (operation -> valor operador valor .)
    RPAREN          reduce using rule 39 (operation -> valor operador valor .)
    COMMA           reduce using rule 39 (operation -> valor operador valor .)
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

  ! MULTIPLY        [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! DIV             [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! MOD             [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! PLUS            [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! MINUS           [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! EQUAL           [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! NEQUAL          [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! GT              [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! LT              [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! GTE             [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! LTE             [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! AND             [ reduce using rule 39 (operation -> valor operador valor .) ]
  ! OR              [ reduce using rule 39 (operation -> valor operador valor .) ]

    operador                       shift and go to state 56

state 80

    (46) parentheses -> LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    MULTIPLY        reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    DIV             reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    MOD             reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    PLUS            reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    MINUS           reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    EQUAL           reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    NEQUAL          reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    GT              reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    LT              reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    GTE             reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    LTE             reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    AND             reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    OR              reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    RPAREN          reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)
    COMMA           reduce using rule 46 (parentheses -> LPAREN valor RPAREN .)


state 81

    (44) declaration -> type NOME ASSIGN valor SEMICOLON .

    RBRACE          reduce using rule 44 (declaration -> type NOME ASSIGN valor SEMICOLON .)
    COMMA           reduce using rule 44 (declaration -> type NOME ASSIGN valor SEMICOLON .)
    SEMICOLON       reduce using rule 44 (declaration -> type NOME ASSIGN valor SEMICOLON .)


state 82

    (49) if_statement -> IF LPAREN valor RPAREN LBRACE . bloco RBRACE
    (47) bloco -> . LBRACE comando RBRACE
    (48) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 89

state 83

    (50) while_statement -> WHILE LPAREN valor RPAREN LBRACE . bloco RBRACE
    (47) bloco -> . LBRACE comando RBRACE
    (48) bloco -> . LBRACE RBRACE

    LBRACE          shift and go to state 7

    bloco                          shift and go to state 90

state 84

    (51) for_statement -> FOR LPAREN for_init SEMICOLON for_condition . SEMICOLON for_update RPAREN comando

    SEMICOLON       shift and go to state 91


state 85

    (60) for_condition -> assignment .

    SEMICOLON       reduce using rule 60 (for_condition -> assignment .)


state 86

    (61) for_condition -> valor .
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    SEMICOLON       reduce using rule 61 (for_condition -> valor .)
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 87

    (62) for_condition -> empty .

    SEMICOLON       reduce using rule 62 (for_condition -> empty .)


state 88

    (58) for_init_comma -> COMMA assignment .
    (59) for_init_comma -> COMMA assignment . for_init_comma
    (58) for_init_comma -> . COMMA assignment
    (59) for_init_comma -> . COMMA assignment for_init_comma

    SEMICOLON       reduce using rule 58 (for_init_comma -> COMMA assignment .)
    COMMA           shift and go to state 76

    for_init_comma                 shift and go to state 92

state 89

    (49) if_statement -> IF LPAREN valor RPAREN LBRACE bloco . RBRACE

    RBRACE          shift and go to state 93


state 90

    (50) while_statement -> WHILE LPAREN valor RPAREN LBRACE bloco . RBRACE

    RBRACE          shift and go to state 94


state 91

    (51) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON . for_update RPAREN comando
    (63) for_update -> . assignment
    (64) for_update -> . valor
    (65) for_update -> . empty
    (40) assignment -> . NOME valor
    (34) valor -> . NUMBER
    (35) valor -> . CHARACTER
    (36) valor -> . boolean
    (37) valor -> . operation
    (38) valor -> . parentheses
    (71) empty -> .
    (32) boolean -> . TRUE
    (33) boolean -> . FALSE
    (39) operation -> . valor operador valor
    (46) parentheses -> . LPAREN valor RPAREN

    NOME            shift and go to state 54
    NUMBER          shift and go to state 37
    CHARACTER       shift and go to state 38
    RPAREN          reduce using rule 71 (empty -> .)
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 44

    for_update                     shift and go to state 95
    assignment                     shift and go to state 96
    valor                          shift and go to state 97
    empty                          shift and go to state 98
    boolean                        shift and go to state 39
    operation                      shift and go to state 40
    parentheses                    shift and go to state 41

state 92

    (59) for_init_comma -> COMMA assignment for_init_comma .

    SEMICOLON       reduce using rule 59 (for_init_comma -> COMMA assignment for_init_comma .)


state 93

    (49) if_statement -> IF LPAREN valor RPAREN LBRACE bloco RBRACE .

    RBRACE          reduce using rule 49 (if_statement -> IF LPAREN valor RPAREN LBRACE bloco RBRACE .)


state 94

    (50) while_statement -> WHILE LPAREN valor RPAREN LBRACE bloco RBRACE .

    RBRACE          reduce using rule 50 (while_statement -> WHILE LPAREN valor RPAREN LBRACE bloco RBRACE .)


state 95

    (51) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update . RPAREN comando

    RPAREN          shift and go to state 99


state 96

    (63) for_update -> assignment .

    RPAREN          reduce using rule 63 (for_update -> assignment .)


state 97

    (64) for_update -> valor .
    (39) operation -> valor . operador valor
    (19) operador -> . MULTIPLY
    (20) operador -> . DIV
    (21) operador -> . MOD
    (22) operador -> . PLUS
    (23) operador -> . MINUS
    (24) operador -> . EQUAL
    (25) operador -> . NEQUAL
    (26) operador -> . GT
    (27) operador -> . LT
    (28) operador -> . GTE
    (29) operador -> . LTE
    (30) operador -> . AND
    (31) operador -> . OR

    RPAREN          reduce using rule 64 (for_update -> valor .)
    MULTIPLY        shift and go to state 57
    DIV             shift and go to state 58
    MOD             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69

    operador                       shift and go to state 56

state 98

    (65) for_update -> empty .

    RPAREN          reduce using rule 65 (for_update -> empty .)


state 99

    (51) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN . comando
    (7) comando -> . declaration
    (8) comando -> . if_statement
    (9) comando -> . while_statement
    (10) comando -> . for_statement
    (11) comando -> . break_statement
    (12) comando -> . continue_statement
    (13) comando -> . return_statement
    (44) declaration -> . type NOME ASSIGN valor SEMICOLON
    (45) declaration -> . type NOME SEMICOLON
    (49) if_statement -> . IF LPAREN valor RPAREN LBRACE bloco RBRACE
    (50) while_statement -> . WHILE LPAREN valor RPAREN LBRACE bloco RBRACE
    (51) for_statement -> . FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando
    (68) break_statement -> . BREAK SEMICOLON
    (69) continue_statement -> . CONTINUE SEMICOLON
    (70) return_statement -> . RETURN valor SEMICOLON
    (14) type -> . INT
    (15) type -> . FLOAT
    (16) type -> . CHAR
    (17) type -> . VOID
    (18) type -> . BOOL

    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 23
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    CHAR            shift and go to state 26
    VOID            shift and go to state 27
    BOOL            shift and go to state 28

    comando                        shift and go to state 100
    declaration                    shift and go to state 10
    if_statement                   shift and go to state 11
    while_statement                shift and go to state 12
    for_statement                  shift and go to state 13
    break_statement                shift and go to state 14
    continue_statement             shift and go to state 15
    return_statement               shift and go to state 16
    type                           shift and go to state 17

state 100

    (51) for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .

    RBRACE          reduce using rule 51 (for_statement -> FOR LPAREN for_init SEMICOLON for_condition SEMICOLON for_update RPAREN comando .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MULTIPLY in state 79 resolved as shift
WARNING: shift/reduce conflict for DIV in state 79 resolved as shift
WARNING: shift/reduce conflict for MOD in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for GT in state 79 resolved as shift
WARNING: shift/reduce conflict for LT in state 79 resolved as shift
WARNING: shift/reduce conflict for GTE in state 79 resolved as shift
WARNING: shift/reduce conflict for LTE in state 79 resolved as shift
WARNING: shift/reduce conflict for AND in state 79 resolved as shift
WARNING: shift/reduce conflict for OR in state 79 resolved as shift
